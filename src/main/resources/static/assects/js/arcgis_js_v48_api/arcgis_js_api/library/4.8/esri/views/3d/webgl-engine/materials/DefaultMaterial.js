// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/DefaultMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"calculateVerticalOffset"\x3e\x3c![CDATA[\r\n  $viewingMode\r\n\r\n#ifdef VERTICAL_OFFSET\r\n  // [ verticalOffsetPerDistance, minWorldLength, maxWorldLength ]\r\n  uniform vec4 verticalOffset;\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n  uniform vec4 screenSizePerspectiveAlignment;\r\n\r\n  $screenSizePerspective\r\n\r\n#endif\r\n\r\n  vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\r\n    float viewDistance \x3d length((view * vec4(worldPos, 1)).xyz);\r\n    float verticalOffsetOffsetDistance \x3d verticalOffset.x * viewDistance;\r\n\r\n#ifdef VIEWING_MODE_GLOBAL\r\n    vec3 worldNormal \x3d normalize(worldPos + localOrigin);\r\n#else\r\n    vec3 worldNormal \x3d vec3(0, 0, 1);\r\n#endif\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n    float cosAngle \x3d dot(worldNormal, normalize(worldPos - camPos));\r\n\r\n    float verticalOffsetScreenHeight \x3d screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\r\n#else\r\n    float verticalOffsetScreenHeight \x3d verticalOffset.x;\r\n#endif\r\n\r\n    // Screen sized offset in world space, used for example for line callouts\r\n    float worldOffset \x3d clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\r\n\r\n    return worldNormal * worldOffset;\r\n  }\r\n#endif\r\n]]\x3e\r\n\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsViewInputs"\x3e\x3c![CDATA[\r\n  uniform mat4 proj;\r\n  uniform mat4 view;\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n  uniform vec3 viewOriginHi;\r\n  uniform vec3 viewOriginLo;\r\n#endif\r\n  uniform vec3 camPos;\r\n  uniform vec3 localOrigin;\r\n]]\x3e\r\n\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsTransformInputs"\x3e\x3c![CDATA[\r\n#ifdef INSTANCED\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n  attribute vec3 modelOriginHi;\r\n  attribute vec3 modelOriginLo;\r\n  attribute mat3 model;\r\n  attribute mat3 modelNormal;\r\n#else\r\n  attribute mat4 model;\r\n  attribute mat4 modelNormal;\r\n#endif\r\n#else /* INSTANCED */\r\n  uniform mat4 model;\r\n  uniform mat4 modelNormal;\r\n#endif /* INSTANCED */\r\n]]\x3e\r\n\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsLocalPosition"\x3e\x3c![CDATA[\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\nvec4 localPosition() { return vvTransformPosition($position, instanceFeatureAttribute); }\r\n#else\r\nvec4 localPosition() { return vec4($position, 1.0); }\r\n#endif\r\n]]\x3e\r\n\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsLocalNormal"\x3e\x3c![CDATA[\r\n  $decodeNormal\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n# ifdef COMPRESSED_NORMALS\r\nvec4 localNormal() { return vvTransformNormal(decodeNormal($normalCompressed), instanceFeatureAttribute); }\r\n# else\r\nvec4 localNormal() { return vvTransformNormal($normal, instanceFeatureAttribute); }\r\n# endif\r\n#else\r\n# ifdef COMPRESSED_NORMALS\r\nvec4 localNormal() { return vec4(decodeNormal($normalCompressed), 1.0); }\r\n# else\r\nvec4 localNormal() { return vec4($normal, 1.0); }\r\n# endif\r\n#endif\r\n]]\x3e\r\n\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsLocalCenter"\x3e\x3c![CDATA[\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n# ifdef VERTICAL_OFFSET\r\nvec4 localCenter() { return vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute); }\r\n# endif\r\n#else\r\n# ifdef VERTICAL_OFFSET\r\nvec4 localCenter() { return vec4(vec3(0, 0, 0), 1.0); }\r\n# endif\r\n#endif\r\n]]\x3e\r\n\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"doublePrecisionArithmethic"\x3e\x3c![CDATA[\r\n// based on https://www.thasler.com/blog/blog/glsl-part2-emu\r\nvec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\r\n  vec3 t1 \x3d hiA + hiB;\r\n  vec3 e \x3d t1 - hiA;\r\n  vec3 t2 \x3d ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\r\n  return t1 + t2;\r\n}\r\n]]\x3e\r\n\x3c/snippet\x3e\r\n\r\n\x3c!-- Keep is synchronized with the logic in Material.js:isVisible --\x3e\r\n\x3csnippet name\x3d"externalColorMix"\x3e\x3c![CDATA[\r\n  vec3 matColor \x3d max(ambient, diffuse); // combine the old material parameters into a single one\r\n  #if defined(VERTEXCOLORS)\r\n      // Internal colors: varying vcolor + uniform ambient/diffuse, external colors: varying vcolorExt\r\n      vec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\r\n      float opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\r\n  #else\r\n      // Internal colors: uniform ambient/diffuse, external colors: varying vcolorExt\r\n      vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\r\n      float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\r\n  #endif\r\n  albedo_+\x3d 0.25 * specular; // don\'t completely ignore specular for now\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"calcMipMapLevel"\x3e\x3c![CDATA[\r\n  float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\r\n    // from:\r\n    //   - OpenGLES Common Profile Specification Version 2.0.25, Section 3.7.7 - Texture Minification\r\n    //   - https://www.opengl.org/discussion_boards/showthread.php/171485-Texture-LOD-calculation-(useful-for-atlasing)\r\n    //   - http://www.linedef.com/virtual-texture-demo.html\r\n    float deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\r\n    return max(0.0, 0.5 * log2(deltaMaxSqr));\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"coverageCorrectionFactor"\x3e\x3c![CDATA[\r\n  // base on https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f\r\n  float coverageCorrectionFactor(vec2 uv) {\r\n#ifdef ALPHA_COVERAGE_CORRECTION\r\n    const float MipScale \x3d 0.25;\r\n    uv *\x3d texSize;\r\n    return 1.0 + max(0.0, calcMipMapLevel(dFdx(uv), dFdy(uv))) * MipScale;\r\n#else\r\n    return 1.0;\r\n#endif\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"alphaThreshold"\x3e\x3c![CDATA[\r\n#ifdef ALPHA_COVERAGE_CORRECTION\r\n  #define ALPHA_THRESHOLD 0.5\r\n#else\r\n  #define ALPHA_THRESHOLD 0.33\r\n#endif\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhongSrc"\x3e\x3c![CDATA[\r\n  $vsViewInputs\r\n  $vsTransformInputs\r\n\r\n#ifdef INSTANCEDCOLOR\r\n  attribute vec4 instanceColor;\r\n#endif\r\n  attribute vec3 $position;\r\n#ifdef COMPRESSED_NORMALS\r\n  attribute vec2 $normalCompressed;\r\n#else\r\n  attribute vec3 $normal;\r\n#endif\r\n  varying vec3 vpos;\r\n  varying vec3 vnormal;\r\n\r\n#ifdef COMPONENTCOLORS\r\n  uniform sampler2D uComponentColorTex;\r\n  uniform vec2 uComponentColorTexInvDim;\r\n\r\n  attribute float $componentIndex;\r\n\r\n  vec4 readComponentColor() {\r\n    float normalizedIndex \x3d ($componentIndex + 0.5) * uComponentColorTexInvDim.x;\r\n    vec2 indexCoord \x3d vec2(\r\n      mod(normalizedIndex, 1.0),\r\n      (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\r\n    );\r\n    return texture2D(uComponentColorTex, indexCoord);\r\n  }\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n  varying float linearDepth;\r\n#endif\r\n\r\n#ifdef VERTEXCOLORS\r\n  attribute vec4 $color;\r\n#endif\r\n\r\n#ifdef SYMBOLVERTEXCOLORS\r\n  attribute vec4 $symbolColor;\r\n#endif\r\n\r\n#if defined(VV_SIZE) || defined(VV_COLOR)\r\n  attribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\r\n$vvUniforms\r\n\r\n#if defined(VERTEXCOLORS)\r\n  varying vec4 vcolor;\r\n#endif\r\n\r\n  // Workaround for https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/13452\r\n  // We pass the externalColor uniform from VS to FS through the vcolorExt varying because\r\n  // there is a driver bug for Intel Integrated Graphics which led to rendering artifacts\r\n  // since the introduction of https://devtopia.esri.com/WebGIS/arcgis-js-api/pull/12673\r\n  // This should be further cleaned up later with through the following issue:\r\n  // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/12763\r\n  uniform vec4 externalColor;\r\n  varying vec4 vcolorExt;\r\n\r\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\r\n  varying mediump float colorMixMode; // varying int is not supported in WebGL\r\n#endif\r\n\r\n  $vvFunctions\r\n\r\n  $colorMixMode\r\n\r\n  $calculateVerticalOffset\r\n\r\n  $vsLocalPosition\r\n  $vsLocalNormal\r\n  $vsLocalCenter\r\n  $doublePrecisionArithmethic\r\n\r\n  void main(void) {\r\n\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n    vpos \x3d model * localPosition().xyz ;\r\n    vnormal \x3d normalize(modelNormal * localNormal().xyz);\r\n\r\n    vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\r\n    vpos -\x3d originDelta;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d model * localCenter().xyz;\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#else /* INSTANCED_DOUBLE_PRECISION */\r\n    vpos \x3d (model * localPosition()).xyz;\r\n    vnormal \x3d normalize((modelNormal * localNormal()).xyz);\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * localCenter()).xyz;\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#endif /* INSTANCED_DOUBLE_PRECISION */\r\n\r\n    gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n    // Shadowmap\'s cascading index used to be based on \'1.0 / gl_FragCoord.w\'\r\n    // (i.e. the perspective interpolation of \'gl_Position.w\'). Precision\r\n    // issues on iPad/iPhone with the \'w\' component require the depth to be\r\n    // passed as varying to properly drive the cascading shadow map index.\r\n    linearDepth \x3d gl_Position.w;\r\n#endif\r\n\r\n#ifdef VERTEXCOLORS\r\n    vcolor \x3d $color * 0.003921568627451; // \x3d 1/255\r\n#endif\r\n\r\n    vcolorExt \x3d externalColor;\r\n\r\n#ifdef INSTANCEDCOLOR\r\n    vcolorExt *\x3d instanceColor;\r\n#endif\r\n#ifdef VV_COLOR\r\n    vcolorExt *\x3d vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\r\n#endif\r\n#ifdef SYMBOLVERTEXCOLORS\r\n    int symbolColorMixMode;\r\n    vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\r\n    colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\r\n#endif\r\n#ifdef COMPONENTCOLORS\r\n    int symbolColorMixMode;\r\n    vcolorExt *\x3d decodeSymbolColor(readComponentColor() * 255.0, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\r\n    colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\r\n#endif\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhongSrc"\x3e\x3c![CDATA[\r\n  uniform vec3 camPos;\r\n  uniform vec3 localOrigin;\r\n\r\n  $sceneLightingDefinitions\r\n  $sceneLightingAdditionalLightGlobal\r\n\r\n  // material parameters\r\n  //////////////////////////////////////////\r\n  uniform vec3 ambient;\r\n  uniform vec3 diffuse;\r\n  uniform vec3 specular;\r\n  uniform float opacity;\r\n  uniform float layerOpacity;\r\n\r\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\r\n  varying mediump float colorMixMode; // varying int is not supported in WebGL\r\n#else\r\n  uniform int colorMixMode;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n  uniform sampler2D depthTex;\r\n  uniform int shadowMapNum;\r\n  uniform vec4 shadowMapDistance;\r\n  uniform mat4 shadowMapMatrix[4];\r\n  uniform float depthHalfPixelSz;\r\n#endif\r\n\r\n#ifdef RECEIVE_SSAO\r\n  uniform sampler2D ssaoTex;\r\n  uniform vec4 viewportPixelSz;\r\n#endif\r\n\r\n\r\n  varying vec3 vpos;\r\n  varying vec3 vnormal;\r\n#if defined(VERTEXCOLORS)\r\n  varying vec4 vcolor;\r\n#endif\r\n  varying vec4 vcolorExt;\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n  varying float linearDepth;\r\n  $evalShadow\r\n#endif\r\n\r\n  $colorMixMode\r\n\r\n  void main() {\r\n    vec3 viewDir \x3d normalize(vpos - camPos);\r\n\r\n    $computeNormal\r\n\r\n    vec3 reflDir \x3d normalize(reflect(viewDir, normal));\r\n\r\n    // compute ssao\r\n    #ifdef RECEIVE_SSAO\r\n        float ssao \x3d texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\r\n        ssao \x3d viewportPixelSz.z \x3c 0.0 ? 1.0 : ssao;\r\n    #else\r\n        float ssao \x3d 1.0;\r\n    #endif\r\n\r\n    // At global scale we create some additional ambient light based on the main light to simulate global illumination\r\n    float additionalAmbientScale;\r\n    vec3 additionalLight \x3d sceneLightingAdditionalLightGlobal(vpos + localOrigin, ssao, additionalAmbientScale);\r\n\r\n    // compute shadowing\r\n    float shadow \x3d 0.0;\r\n    #ifdef RECEIVE_SHADOWS\r\n      shadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\r\n    #elif defined(VIEWING_MODE_GLOBAL)\r\n      // at global scale (and in global scenes) we fall back to this approximation\r\n      // to shadow objects on the dark side of the earth\r\n      shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\r\n    #endif\r\n\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhong"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  $vsPhongSrc\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhong"\x3e\x3c![CDATA[\r\n    $fsprecisionf\r\n\r\n    $fsPhongSrc\r\n\r\n    vec4 texColor \x3d vec4(1,1,1,1);\r\n    $externalColorMix\r\n\r\n#ifdef TRANSPARENCY_DISCARD\r\n    if (opacity_ \x3c 0.001) {\r\n      discard;\r\n    }\r\n#endif\r\n\r\n    vec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n\r\n    gl_FragColor \x3d vec4(shadedColor, opacity_);\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhongTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  attribute vec2 $uv0;\r\n  varying vec2 vtc;\r\n  $vsPhongSrc\r\n#ifndef FLIPV\r\n    vtc \x3d $uv0;\r\n#else\r\n    vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhongTextured"\x3e\x3c![CDATA[\r\n  $enableRequiredExtensions\r\n  $fsprecisionf\r\n  $alphaThreshold\r\n\r\n  uniform sampler2D tex;\r\n  uniform vec2 texSize;\r\n  varying vec2 vtc;\r\n\r\n  $calcMipMapLevel\r\n  $coverageCorrectionFactor\r\n\r\n  $fsPhongSrc\r\n\r\n    // read texture color\r\n    vec4 texColor \x3d texture2D(tex, vtc);\r\n    if (texColor.a * coverageCorrectionFactor(vtc) \x3c ALPHA_THRESHOLD) {\r\n      discard;\r\n    }\r\n\r\n    $externalColorMix\r\n\r\n#ifdef TRANSPARENCY_DISCARD\r\n    if (opacity_ \x3c 0.001) {\r\n      discard;\r\n    }\r\n#endif\r\n\r\n    vec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n\r\n    gl_FragColor \x3d vec4(shadedColor, opacity_);\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhongAtlasTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  attribute vec4 $uv0;\r\n  attribute vec4 $region;\r\n  varying vec2 vtc;\r\n  varying vec4 regionV;\r\n  $vsPhongSrc\r\n#ifndef FLIPV\r\n    vtc \x3d $uv0.xy;\r\n#else\r\n    vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n    regionV \x3d $region/65535.0;\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhongAtlasTextured"\x3e\x3c![CDATA[\r\n  $enableRequiredExtensions\r\n  $fsprecisionf\r\n  $alphaThreshold\r\n\r\n  uniform sampler2D tex;\r\n  uniform vec2 texSize;\r\n  varying vec2 vtc;\r\n  varying vec4 regionV;\r\n\r\n  $calcMipMapLevel\r\n  $coverageCorrectionFactor\r\n\r\n  $fsPhongSrc\r\n\r\n    vec2 uv \x3d vtc;\r\n    uv \x3d fract(uv);\r\n    //[umin, vmin, umax, vmax]\r\n\r\n    vec2 atlasScale \x3d regionV.zw - regionV.xy;\r\n    uv \x3d uv.xy * atlasScale + regionV.xy;\r\n\r\n    vec4 texColor;\r\n\r\n    // calculate derivative of continuous texture coordinate\r\n    // to avoid mipmapping artifacts caused by manual wrapping in shader\r\n    vec2 dUVdx \x3d dFdx(vtc) * atlasScale;\r\n    vec2 dUVdy \x3d dFdy(vtc) * atlasScale;\r\n\r\n    #ifdef GL_EXT_shader_texture_lod\r\n      #extension GL_EXT_shader_texture_lod : enable\r\n\r\n      // workaround for artifacts in Windows 10 using Intel HD Graphics 4000 series\r\n      // see: https://devtopia.esri.com/Zurich-R-D-Center/arcgis-js-api-canvas3d-issues/issues/768\r\n      const float epsilon \x3d 1.0E-32;\r\n      float zeroUVShift \x3d uv.x \x3d\x3d 0.0 \x26\x26 uv.y \x3d\x3d 0.0 ? epsilon : 0.0;\r\n\r\n      texColor \x3d texture2DGradEXT(tex, uv + zeroUVShift, dUVdx, dUVdy);\r\n    #else\r\n      // use bias to compensate for difference in automatic vs desired mipmap level\r\n      vec2 dUVdxAuto \x3d dFdx(uv);\r\n      vec2 dUVdyAuto \x3d dFdy(uv);\r\n      float mipMapLevel \x3d calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\r\n      float autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\r\n      texColor \x3d texture2D(tex, uv, mipMapLevel - autoMipMapLevel);\r\n    #endif\r\n\r\n    if (texColor.a * coverageCorrectionFactor(uv) \x3c ALPHA_THRESHOLD) {\r\n      discard;\r\n    }\r\n\r\n    $externalColorMix\r\n\r\n#ifdef TRANSPARENCY_DISCARD\r\n    if (opacity_ \x3c 0.001) {\r\n      discard;\r\n    }\r\n#endif\r\n\r\n    vec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n    gl_FragColor \x3d vec4(shadedColor, opacity_);\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsDepthSrc"\x3e\x3c![CDATA[\r\n  $vsViewInputs\r\n  $vsTransformInputs\r\n\r\n  uniform vec2 nearFar;\r\n  attribute vec3 $position;\r\n  varying float depth;\r\n\r\n  $vvUniforms\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\n  attribute vec4 instanceFeatureAttribute;\r\n#endif\r\n  $vvFunctions\r\n\r\n  $calculateVerticalOffset\r\n\r\n  $vsLocalPosition\r\n  $vsLocalCenter\r\n  $doublePrecisionArithmethic\r\n\r\n  void main(void) {\r\n\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n    vec3 vpos \x3d model * localPosition().xyz;\r\n\r\n    vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\r\n    vpos -\x3d originDelta;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d model * localCenter().xyz;\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#else /* INSTANCED_DOUBLE_PRECISION */\r\n    vec3 vpos \x3d (model * localPosition()).xyz;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * localCenter()).xyz;\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#endif /* INSTANCED_DOUBLE_PRECISION */\r\n\r\n    vec4 eye \x3d view * vec4(vpos, 1);\r\n\r\n    gl_Position \x3d proj * eye;\r\n    depth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsDepth"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  $vsDepthSrc\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsDepthTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  attribute vec2 $uv0;\r\n  varying vec2 vtc;\r\n  $vsDepthSrc\r\n#ifndef FLIPV\r\n        vtc \x3d $uv0;\r\n#else\r\n        vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsNormalSrc"\x3e\x3c![CDATA[\r\n  $vsViewInputs\r\n  $vsTransformInputs\r\n\r\n  uniform mat4 viewNormal;\r\n  attribute vec3 $position;\r\n#ifdef COMPRESSED_NORMALS\r\n  attribute vec2 $normalCompressed;\r\n#else\r\n  attribute vec3 $normal;\r\n#endif\r\n  varying vec3 vnormal;\r\n\r\n  $vvUniforms\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\n  attribute vec4 instanceFeatureAttribute;\r\n#endif\r\n  $vvFunctions\r\n\r\n  $calculateVerticalOffset\r\n\r\n  $vsLocalPosition\r\n  $vsLocalNormal\r\n  $vsLocalCenter\r\n  $doublePrecisionArithmethic\r\n\r\n  void main(void) {\r\n\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n    vec3 vpos \x3d model * localPosition().xyz + modelOriginHi;\r\n    vnormal \x3d normalize((viewNormal * vec4(modelNormal * localNormal().xyz, 1.0)).xyz);\r\n\r\n    vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\r\n    vpos -\x3d originDelta;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d model * localCenter().xyz;\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#else /* INSTANCED_DOUBLE_PRECISION */\r\n    vec3 vpos \x3d (model * localPosition()).xyz;\r\n    vnormal \x3d normalize((viewNormal * modelNormal * localNormal()).xyz);\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * localCenter()).xyz;\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#endif /* INSTANCED_DOUBLE_PRECISION */\r\n\r\n    gl_Position \x3d proj * view * vec4(vpos, 1);\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsNormal"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  $vsNormalSrc\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsNormalTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  attribute vec2 $uv0;\r\n  varying vec2 vtc;\r\n  $vsNormalSrc\r\n#ifndef FLIPV\r\n    vtc \x3d $uv0;\r\n#else\r\n    vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsHighlightSrc"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  $vsViewInputs\r\n  $vsTransformInputs\r\n\r\n  attribute vec3 $position;\r\n\r\n  $vvUniforms\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\n  attribute vec4 instanceFeatureAttribute;\r\n#endif\r\n  $vvFunctions\r\n\r\n  $calculateVerticalOffset\r\n\r\n  $vsLocalPosition\r\n  $vsLocalCenter\r\n  $doublePrecisionArithmethic\r\n\r\n  void main(void) {\r\n\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n    vec3 vpos \x3d model * localPosition().xyz;\r\n\r\n    vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\r\n    vpos -\x3d originDelta;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d model * localCenter().xyz;\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#else /* INSTANCED_DOUBLE_PRECISION */\r\n    vec3 vpos \x3d (model * localPosition()).xyz;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * localCenter()).xyz;\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#endif /* INSTANCED_DOUBLE_PRECISION */\r\n\r\n    gl_Position \x3d proj * view * vec4(vpos, 1);\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsHighlight"\x3e\x3c![CDATA[\r\n  $vsHighlightSrc\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsHighlightTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  attribute vec2 $uv0;\r\n  varying vec2 vtc;\r\n  $vsHighlightSrc\r\n#ifndef FLIPV\r\n    vtc \x3d $uv0;\r\n#else\r\n    vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsDepthSrc"\x3e\x3c![CDATA[\r\n  varying float depth;\r\n\r\n  void main() {\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsDepth"\x3e\x3c![CDATA[\r\n  $enableRequiredExtensions\r\n  $fsprecisionf\r\n\r\n  $calcFragDepth\r\n  $float2rgba\r\n  $fsDepthSrc\r\n#ifndef BIAS_SHADOWMAP\r\n    gl_FragColor \x3d float2rgba(depth);\r\n#else\r\n    gl_FragColor \x3d float2rgba(calcFragDepth(depth));\r\n#endif\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsDepthTextured"\x3e\x3c![CDATA[\r\n  $enableRequiredExtensions\r\n  $fsprecisionf\r\n  $alphaThreshold\r\n\r\n  uniform sampler2D tex;\r\n  uniform vec2 texSize;\r\n  varying vec2 vtc;\r\n\r\n  $calcFragDepth\r\n  $float2rgba\r\n  $calcMipMapLevel\r\n  $coverageCorrectionFactor\r\n\r\n  $fsDepthSrc\r\n    if (texture2D(tex, vtc).a * coverageCorrectionFactor(vtc) \x3c ALPHA_THRESHOLD) {\r\n      discard;\r\n    }\r\n#ifndef BIAS_SHADOWMAP\r\n    gl_FragColor \x3d float2rgba(depth);\r\n#else\r\n    gl_FragColor \x3d float2rgba(calcFragDepth(depth));\r\n#endif\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsNormal"\x3e\x3c![CDATA[\r\n  $fsprecisionf\r\n\r\n  varying vec3 vnormal;\r\n  void main() {\r\n    vec3 normal \x3d normalize(vnormal);\r\n    if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\r\n\r\n#ifndef ALPHA_ZERO\r\n    gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\r\n#else\r\n    gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\r\n#endif\r\n\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsNormalTextured"\x3e\x3c![CDATA[\r\n  $enableRequiredExtensions\r\n  $fsprecisionf\r\n  $alphaThreshold\r\n\r\n  varying vec3 vnormal;\r\n  varying vec2 vtc;\r\n  uniform sampler2D tex;\r\n  uniform vec2 texSize;\r\n\r\n  $calcMipMapLevel\r\n  $coverageCorrectionFactor\r\n\r\n  void main() {\r\n    if (texture2D(tex, vtc).a * coverageCorrectionFactor(vtc) \x3c ALPHA_THRESHOLD) {\r\n      discard;\r\n    }\r\n    vec3 normal \x3d normalize(vnormal);\r\n    if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\r\n#ifndef ALPHA_ZERO\r\n    gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\r\n#else\r\n    gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\r\n#endif\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsHighlight"\x3e\x3c![CDATA[\r\n  $fsprecisionf\r\n  uniform sampler2D depthTex;\r\n  uniform vec4 highlightViewportPixelSz;\r\n\r\n  void main() {\r\n    $highlightWrite\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsHighlightTextured"\x3e\x3c![CDATA[\r\n  $enableRequiredExtensions\r\n  $fsprecisionf\r\n  $alphaThreshold\r\n\r\n  varying vec2 vtc;\r\n  uniform sampler2D tex;\r\n  uniform vec2 texSize;\r\n\r\n  uniform sampler2D depthTex;\r\n  uniform vec4 highlightViewportPixelSz;\r\n\r\n  $calcMipMapLevel\r\n  $coverageCorrectionFactor\r\n\r\n  void main() {\r\n    if (texture2D(tex, vtc).a * coverageCorrectionFactor(vtc) \x3c ALPHA_THRESHOLD) {\r\n      discard;\r\n    }\r\n\r\n    $highlightWrite\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("require exports ../../../../core/tsSupport/extendsHelper dojo/has dojo/text!./DefaultMaterial.xml ../../layers/graphics/graphicUtils ../../support/buffer/glUtil ../../support/buffer/InterleavedLayout ../lib/DefaultVertexAttributeLocations ../lib/gl-matrix ../lib/GLMaterialTexture ../lib/Material ../lib/RenderSlot ../lib/ShaderVariations ../lib/Util ./internal/MaterialUtil ../../../webgl/Program ../../../webgl/Util".split(" "),function(F,ia,l,T,U,V,G,H,m,r,t,W,B,u,X,g,k,v){function w(f,c){var a=
f.gl;(c.cullFace?"none"===c.cullFace:c.transparent)?f.setFaceCullingEnabled(!1):(f.setFaceCullingEnabled(!0),"front"===c.cullFace&&f.setCullFace(a.FRONT))}function x(f,c){var a=f.gl;(c.cullFace?"none"===c.cullFace:c.transparent)?f.setFaceCullingEnabled(!0):(f.setFaceCullingEnabled(!1),"front"===c.cullFace&&f.setCullFace(a.BACK))}function n(f,c){return f?B.TRANSPARENT_MATERIAL:c?B.STENCIL_MATERIAL:B.OPAQUE_MATERIAL}function y(f,c){var a=c.vvSizeEnabled;c.vvSizeEnabled?(f.setUniform3fv("vvSizeMinSize",
c.vvSizeMinSize),f.setUniform3fv("vvSizeMaxSize",c.vvSizeMaxSize),f.setUniform3fv("vvSizeOffset",c.vvSizeOffset),f.setUniform3fv("vvSizeFactor",c.vvSizeFactor)):a&&f.setUniform3fv("vvSizeValue",c.vvSizeValue);a&&(f.setUniform3fv("vvSymbolAnchor",c.vvSymbolAnchor),V.computeObjectRotation(c.vvSymbolRotation[2],c.vvSymbolRotation[0],c.vvSymbolRotation[1],C.identity(I)),f.setUniformMatrix3fv("vvSymbolRotation",C.toMat3(I,Y)));c.vvColorEnabled&&(f.setUniform1fv("vvColorValues",c.vvColorValues),f.setUniform4fv("vvColorColors",
c.vvColorColors))}function z(f,c){f.vvSizeEnabled=c.vvSizeEnabled;f.vvSizeMinSize=c.vvSizeMinSize;f.vvSizeMaxSize=c.vvSizeMaxSize;f.vvSizeOffset=c.vvSizeOffset;f.vvSizeFactor=c.vvSizeFactor;f.vvSizeValue=c.vvSizeValue;f.vvSymbolAnchor=c.vvSymbolAnchor;f.vvSymbolRotation=c.vvSymbolRotation}var h=r.vec3d,J=r.vec4d,K=r.mat3d,C=r.mat4d,L=X.assert;F=function(f){function c(a,b){b=f.call(this,b)||this;b.supportsEdges=!0;b.params=g.copyParameters(a,Z);b.instanced=!!a.instanced;b.vertexBufferLayout=c.getVertexBufferLayout(b.params);
b.instanceBufferLayout=b.instanced?c.getInstanceBufferLayout(b.params):null;return b}l(c,f);c.prototype.isVisible=function(){var a=this.params;if(!f.prototype.isVisible.call(this)||0===a.layerOpacity)return!1;var b=p&&a.instanced,d=a.vertexColors,e=a.symbolColors,b=!!b&&-1<b.indexOf("color"),c=a.vvColorEnabled,g="replace"===a.colorMixMode,h=0<a.opacity,a=a.externalColor&&0<a.externalColor[3];return d&&(b||c||e)?g?!0:h:d?g?a:h:b||c||e?g?!0:h:g?a:h};c.prototype.getParams=function(){return this.params};
c.prototype.getParameterValues=function(){var a=this.params;return{textureId:a.textureId,ambient:a.ambient,diffuse:a.diffuse,specular:a.specular,externalColor:a.externalColor,colorMixMode:a.colorMixMode,opacity:a.opacity,layerOpacity:a.layerOpacity,transparent:a.transparent,polygonOffset:a.polygonOffset,atlasRegions:a.atlasRegions,flipV:a.flipV,doubleSided:a.doubleSided,doubleSidedType:a.doubleSidedType,cullFace:a.cullFace,writeStencil:a.writeStencil,receiveSSAO:a.receiveSSAO,castShadows:a.castShadows,
verticalOffset:a.verticalOffset,screenSizePerspective:a.screenSizePerspective,vvSizeEnabled:a.vvSizeEnabled,vvSizeMinSize:a.vvSizeMinSize,vvSizeMaxSize:a.vvSizeMaxSize,vvSizeOffset:a.vvSizeOffset,vvSizeFactor:a.vvSizeFactor,vvSizeValue:a.vvSizeValue,vvColorEnabled:a.vvColorEnabled,vvColorValues:a.vvColorValues,vvColorColors:a.vvColorColors,instancedDoublePrecision:a.instancedDoublePrecision,compressedNormals:a.compressedNormals,groundNormalShading:a.groundNormalShading,vvSymbolAnchor:a.vvSymbolAnchor,
vvSymbolRotation:a.vvSymbolRotation}};c.prototype.setParameterValues=function(a){var b=this.params,d;for(d in a)"textureId"===d&&L(b.textureId,"Can only change texture of material that already has a texture"),"castShadows"===d&&L(a.castShadows===b.castShadows,"Can not change shadow casting behavior."),b[d]=a[d];this.notifyDirty("matChanged")};c.prototype.getOutputAmount=function(a){var b=v.getStride(this.vertexBufferLayout)/4;return a*b};c.prototype.getVertexBufferLayout=function(){return this.vertexBufferLayout};
c.prototype.getInstanceBufferLayout=function(){return this.instanceBufferLayout};c.prototype.fillInterleaved=function(a,b,d,e,c,f,h){g.fillInterleaved(a,b,d,e,this.vertexBufferLayout,c,f,h)};c.prototype.intersect=function(a,b,d,e,c,f,m,k){if(null!==this.params.verticalOffset){k=e.camera;h.set3(d[12],d[13],d[14],D);var q=h.subtract(D,k.eye,aa),p=h.length(q),l=h.scale(q,1/p),n=null,q=null;switch(e.viewingMode){case "global":q=h.normalize(D,M);break;case "local":q=h.set(ba,M)}this.params.screenSizePerspective&&
(n=h.dot(q,l));k=g.verticalOffsetAtDistance(k,p,this.params.verticalOffset,n,this.params.screenSizePerspective);h.scale(q,k);K.multiplyVec3(e.transformInverseRotation,q,E);c=h.subtract(c,E,ca);f=h.subtract(f,E,da)}g.intersectTriangleGeometry(a,b,d,e,c,f,m)};c.prototype.getGLMaterials=function(){return{color:ea,depthShadowMap:this.params.castShadows?fa:null,normal:ga,depth:N,highlight:ha}};c.prototype.getAllTextureIds=function(){var a=this.params,b=[];a.textureId&&b.push(a.textureId);return b};c.loadShaders=
function(a,b,d){a._parse(U);p=null!==d.capabilities.instancing;var e=new u("phong",["vsPhong","fsPhong"],null,b,a,d);e.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);e.addDefine("Color","VERTEXCOLORS");e.addDefine("symbolColor","SYMBOLVERTEXCOLORS");e.addDefine("FlipV","FLIPV");e.addDefine("DoubleSided","DOUBLESIDED");e.addDefine("WindingOrderDoubleSided","WINDINGORDERDOUBLESIDED");e.addDefine("Instanced","INSTANCED");
e.addDefine("instancedDoublePrecision","INSTANCED_DOUBLE_PRECISION");e.addDefine("InstColor","INSTANCEDCOLOR");e.addDefine("ReceiveShadows","RECEIVE_SHADOWS");e.addDefine("ReceiveSSAO","RECEIVE_SSAO");e.addDefine("vvSize","VV_SIZE");e.addDefine("vvColor","VV_COLOR");e.addDefine("VerticalOffset","VERTICAL_OFFSET");e.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");e.addDefine("groundNormalShading","GROUND_NORMAL_SHADING");e.addDefine("compressedNormals","COMPRESSED_NORMALS");e.addDefine("componentColor",
"COMPONENTCOLORS");e.addDefine("transparencyDiscard","TRANSPARENCY_DISCARD");e.addDefine("alphaCoverageCorrection","ALPHA_COVERAGE_CORRECTION");b.addShaderVariations(O,e);e=new u("depth",["vsDepth","fsDepth"],null,b,a,d);e.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);e.addDefine("FlipV","FLIPV");e.addDefine("Instanced","INSTANCED");e.addDefine("instancedDoublePrecision","INSTANCED_DOUBLE_PRECISION");e.addDefine("ShadowMap",
"BIAS_SHADOWMAP");e.addDefine("vvSize","VV_SIZE");e.addDefine("VerticalOffset","VERTICAL_OFFSET");e.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");e.addDefine("transparencyDiscard","TRANSPARENCY_DISCARD");e.addDefine("alphaCoverageCorrection","ALPHA_COVERAGE_CORRECTION");b.addShaderVariations(P,e);e=new u("normal",["vsNormal","fsNormal"],null,b,a,d);e.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);e.addDefine("FlipV",
"FLIPV");e.addDefine("Instanced","INSTANCED");e.addDefine("instancedDoublePrecision","INSTANCED_DOUBLE_PRECISION");e.addDefine("vvSize","VV_SIZE");e.addDefine("VerticalOffset","VERTICAL_OFFSET");e.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");e.addDefine("compressedNormals","COMPRESSED_NORMALS");e.addDefine("transparencyDiscard","TRANSPARENCY_DISCARD");e.addDefine("alphaCoverageCorrection","ALPHA_COVERAGE_CORRECTION");b.addShaderVariations(Q,e);e=new u("highlight",["vsHighlight","fsHighlight"],
null,b,a,d);e.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);e.addDefine("FlipV","FLIPV");e.addDefine("Instanced","INSTANCED");e.addDefine("instancedDoublePrecision","INSTANCED_DOUBLE_PRECISION");e.addDefine("vvSize","VV_SIZE");e.addDefine("VerticalOffset","VERTICAL_OFFSET");e.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");e.addDefine("transparencyDiscard","TRANSPARENCY_DISCARD");e.addDefine("alphaCoverageCorrection",
"ALPHA_COVERAGE_CORRECTION");b.addShaderVariations(R,e);var e=new k(d,a.vsDepth,a.fsDepth,m.Default3D,["BIAS_SHADOWMAP 1"]),c=new k(d,a.vsDepthTextured,a.fsDepthTextured,m.Default3D,["BIAS_SHADOWMAP 1"]),f=new k(d,a.vsDepth,a.fsDepth,m.Default3D),g=new k(d,a.vsDepthTextured,a.fsDepthTextured,m.Default3D),h=new k(d,a.vsNormal,a.fsNormal,m.Default3D),l=new k(d,a.vsNormalTextured,a.fsNormalTextured,m.Default3D),n=new k(d,a.vsHighlight,a.fsHighlight,m.Default3D);a=new k(d,a.vsHighlightTextured,a.fsHighlightTextured,
m.Default3D);b.add("depthShadowMap",e);b.add("depthTexturedShadowMap",c);b.add("depth",f);b.add("depthTextured",g);b.add("normal",h);b.add("normalTextured",l);b.add("highlight",n);b.add("highlightTextured",a)};c.getVertexBufferLayout=function(a){var b=H.newLayout().vec3f("position");a.groundNormalShading||(b=a.compressedNormals?b.vec2i16("normalCompressed",{glNormalized:!0}):b.vec3f("normal"));a.textureId&&(b=b.vec2f("uv0"),a.atlasRegions&&(b=b.vec4u16("region")));a.vertexColors&&(b=b.vec4u8("color"));
a.symbolColors&&(b=b.vec4u8("symbolColor"));a.componentIndices&&(b=b.u16("componentIndex").u16("_padding",{glPadding:!0}));return G.glLayout(b)};c.getInstanceBufferLayout=function(a){var b=H.newLayout(),b=a.instancedDoublePrecision?b.vec3f("modelOriginHi").vec3f("modelOriginLo").mat3f("model").mat3f("modelNormal"):b.mat4f("model").mat4f("modelNormal");a.instanced&&-1<a.instanced.indexOf("color")&&(b=b.vec4f("instanceColor"));a.instanced&&-1<a.instanced.indexOf("featureAttribute")&&(b=b.vec4f("instanceFeatureAttribute"));
return G.glLayout(b,{divisor:1})};return c}(W);var ea=function(f){function c(a,b,d){b=f.call(this,a,b,d,a.getParams().textureId)||this;b.programs=[[null,null],[null,null]];b.params=g.copyParameters(a.getParams());b.slot=n(b.params.transparent,b.params.writeStencil);a=b.params;b.texturing=a.textureId?a.atlasRegions?"AtlasTextured":"Textured":"none";d=p&&a.instanced;b.instanced=!!d;b.instancedColor=!!d&&-1<d.indexOf("color");b.pseudoInstancedColor=!p&&a.instanced&&-1<a.instanced.indexOf("color");b._loadPrograms();
return b}l(c,f);c.prototype._loadPrograms=function(){this.programs[0][0]=this._loadProgram(!1,!1);this.programs[1][0]=this._loadProgram(!0,!1);this.params.receiveSSAO?(this.programs[0][1]=this._loadProgram(!1,!0),this.programs[1][1]=this._loadProgram(!0,!0),this.allPrograms=this.programs[0].concat(this.programs[1])):(this.programs[0][1]=this.programs[0][0],this.programs[1][1]=this.programs[1][0],this.allPrograms=[this.programs[0][0],this.programs[1][0]])};c.prototype._loadProgram=function(a,b){var d=
this.params;return this.programRep.getShaderVariationsProgram(O,[this.texturing,d.vertexColors,d.symbolColors,d.flipV,d.doubleSided&&"normal"===d.doubleSidedType,d.doubleSided&&"winding-order"===d.doubleSidedType,!!this.instanced,d.instancedDoublePrecision,this.instancedColor,a,b,d.vvSizeEnabled,d.vvColorEnabled,null!==d.verticalOffset,null!==d.screenSizePerspective,d.groundNormalShading,d.compressedNormals,null!=d.componentColorBuffer,d.transparent,A])};c.prototype.beginSlot=function(a){return a===
this.slot};c.prototype.getProgram=function(){return this.program||this.programs[0][0]};c.prototype.getPrograms=function(){return this.allPrograms};c.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.ambient=a.ambient;b.diffuse=a.diffuse;b.specular=a.specular;b.externalColor=a.externalColor;b.colorMixMode=a.colorMixMode;b.opacity=a.opacity;b.layerOpacity=a.layerOpacity;b.polygonOffset=a.polygonOffset;b.flipV=a.flipV;b.doubleSided=a.doubleSided;b.doubleSidedType=
a.doubleSidedType;b.cullFace=a.cullFace;b.receiveSSAO=a.receiveSSAO;b.castShadows=a.castShadows;b.verticalOffset=a.verticalOffset;b.screenSizePerspective=a.screenSizePerspective;z(b,a);b.vvColorEnabled=a.vvColorEnabled;b.vvColorValues=a.vvColorValues;b.vvColorColors=a.vvColorColors;b.transparent!==a.transparent&&(this.slot=n(a.transparent,a.writeStencil),b.transparent=a.transparent);b.instancedDoublePrecision=a.instancedDoublePrecision;b.compressedNormals=a.compressedNormals;b.groundNormalShading=
a.groundNormalShading;this.updateTexture(a.textureId);a.atlasRegions&&(b.atlasRegions=a.atlasRegions);b.blendModeOneOne=a.blendModeOneOne;b.inverseWindingOrder=a.inverseWindingOrder;this._loadPrograms()};c.prototype.bind=function(a,b){var d=a.gl,e=this.params,c=this.program=this.programs[b.shadowMappingEnabled?1:0][b.ssaoEnabled?1:0];a.bindProgram(c);c.setUniform3fv("ambient",e.ambient);c.setUniform3fv("diffuse",e.diffuse);c.setUniform3fv("specular",e.specular);c.setUniform4fv("externalColor",e.externalColor);
c.setUniform1i("colorMixMode",g.colorMixModes[e.colorMixMode]);c.setUniform1f("opacity",e.opacity);c.setUniform1f("layerOpacity",e.layerOpacity);g.bindVerticalOffset(e.verticalOffset,b,c);g.bindScreenSizePerspective(e.screenSizePerspective,c);y(c,e);this.bindTexture(a,c);"none"!==this.texturing&&this.bindTextureSize(a,c);a.setBlendFunctionSeparate(d.SRC_ALPHA,d.ONE_MINUS_SRC_ALPHA,d.ONE,d.ONE_MINUS_SRC_ALPHA);e.inverseWindingOrder&&a.setFrontFace(d.CW);e.transparent?(a.setBlendingEnabled(!0),e.blendModeOneOne?
(a.setBlendFunction(d.ONE,d.ONE),a.setDepthWriteEnabled(!1)):a.setBlendFunctionSeparate(d.SRC_ALPHA,d.ONE_MINUS_SRC_ALPHA,d.ONE,d.ONE_MINUS_SRC_ALPHA)):a.setBlendingEnabled(!1);e.polygonOffset&&(a.setPolygonOffsetFillEnabled(!0),a.setPolygonOffset(2,2));w(a,e);a.setDepthTestEnabled(!0);e.componentIndices&&e.componentColorBuffer&&(e.componentColorBuffer.updateTexture(),e.componentColorBuffer.bind(c,{texName:"uComponentColorTex",invDimName:"uComponentColorTexInvDim",unit:1}))};c.prototype.release=function(a,
b){b=a.gl;a.setPolygonOffsetFillEnabled(!1);x(a,this.params);a.setBlendingEnabled(!1);a.setBlendFunctionSeparate(b.SRC_ALPHA,b.ONE_MINUS_SRC_ALPHA,b.ONE,b.ONE_MINUS_SRC_ALPHA);a.setDepthWriteEnabled(!0);a.setFrontFace(b.CCW)};c.prototype.bindView=function(a,b){a=this.program=this.programs[b.shadowMappingEnabled?1:0][b.ssaoEnabled?1:0];var d=this.params,e=d.instancedDoublePrecision?[b.viewInvTransp[3],b.viewInvTransp[7],b.viewInvTransp[11]]:b.origin;g.bindView(e,b.view,a);g.bindCamPos(e,b.viewInvTransp,
a);d.instancedDoublePrecision&&g.bindViewOriginDouble(e,a);b.shadowMappingEnabled&&b.shadowMap.bindView(a,e)};c.prototype.bindInstance=function(a,b){a=this.program;a.setUniformMatrix4fv("model",b.transformation);a.setUniformMatrix4fv("modelNormal",b.transformationNormal);b.instanceParameters&&this.pseudoInstancedColor&&(b=b.instanceParameters.color)&&(J.multiply(b,this.params.externalColor,S),a.setUniform4fv("externalColor",S))};c.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return c}(t),
N=function(f){function c(a,b,d,e){void 0===e&&(e=!1);d=f.call(this,a,b,d,a.getParams().textureId)||this;d.params=g.copyParameters(a.getParams());d.instanced=p&&!!d.params.instanced;d.texturing=v.hasAttribute(a.getVertexBufferLayout(),"uv0")?"Textured":"none";d.program=b.getShaderVariationsProgram(P,[d.texturing,d.params.flipV,d.instanced,d.params.instancedDoublePrecision,e,d.params.vvSizeEnabled,null!==d.params.verticalOffset,null!==d.params.screenSizePerspective,d.params.transparent,A]);d.slot=n(d.params.transparent,
d.params.writeStencil);return d}l(c,f);c.prototype.beginSlot=function(a){return a===this.slot};c.prototype.getProgram=function(){return this.program};c.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.cullFace=a.cullFace;b.inverseWindingOrder=a.inverseWindingOrder;b.flipV=a.flipV;z(b,a);this.updateTexture(a.textureId);b.instancedDoublePrecision=a.instancedDoublePrecision};c.prototype.bind=function(a,b){var d=a.gl,e=this.program,c=this.params;a.bindProgram(e);e.setUniform2fv("nearFar",
b.nearFar);c.inverseWindingOrder&&a.setFrontFace(d.CW);g.bindVerticalOffset(c.verticalOffset,b,e);g.bindScreenSizePerspective(c.screenSizePerspective,e);y(e,c);this.bindTexture(a,e);w(a,c);a.setDepthTestEnabled(!0)};c.prototype.release=function(a){var b=a.gl,d=this.params;x(a,d);d.inverseWindingOrder&&a.setFrontFace(b.CCW)};c.prototype.bindView=function(a,b){a=this.program;var d=this.params,c=d.instancedDoublePrecision?[b.viewInvTransp[3],b.viewInvTransp[7],b.viewInvTransp[11]]:b.origin;g.bindView(c,
b.view,a);d.screenSizePerspective&&g.bindCamPos(c,b.viewInvTransp,a);d.instancedDoublePrecision&&g.bindViewOriginDouble(c,a)};c.prototype.bindInstance=function(a,b){this.program.setUniformMatrix4fv("model",b.transformation)};c.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return c}(t),fa=function(f){function c(a,b,d){return f.call(this,a,b,d,!0)||this}l(c,f);return c}(N),ga=function(f){function c(a,b,d,c){void 0===c&&(c=!1);d=f.call(this,a,b,d,a.getParams().textureId)||this;d.params=g.copyParameters(a.getParams());
d.instanced=p&&!!d.params.instanced;d.texturing=v.hasAttribute(a.getVertexBufferLayout(),"uv0")?"Textured":"none";d.program=b.getShaderVariationsProgram(Q,[d.texturing,d.params.flipV,d.instanced,d.params.instancedDoublePrecision,d.params.vvSizeEnabled,null!==d.params.verticalOffset,null!==d.params.screenSizePerspective,d.params.compressedNormals,d.params.transparent,A]);d.slot=n(d.params.transparent,d.params.writeStencil);return d}l(c,f);c.prototype.beginSlot=function(a){return a===this.slot};c.prototype.getProgram=
function(){return this.program};c.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.cullFace=a.cullFace;b.inverseWindingOrder=a.inverseWindingOrder;b.flipV=a.flipV;z(b,a);this.updateTexture(a.textureId);b.instancedDoublePrecision=a.instancedDoublePrecision};c.prototype.bind=function(a,b){var d=a.gl,c=this.program,f=this.params;a.bindProgram(c);this.bindTexture(a,c);g.bindVerticalOffset(f.verticalOffset,b,c);g.bindScreenSizePerspective(f.screenSizePerspective,c);
y(c,f);w(a,f);f.inverseWindingOrder&&a.setFrontFace(d.CW);a.setDepthTestEnabled(!0)};c.prototype.release=function(a){var b=a.gl,d=this.params;x(a,d);d.inverseWindingOrder&&a.setFrontFace(b.CCW)};c.prototype.bindView=function(a,b){a=this.program;var d=this.params,c=d.instancedDoublePrecision?[b.viewInvTransp[3],b.viewInvTransp[7],b.viewInvTransp[11]]:b.origin;g.bindView(c,b.view,a);a.setUniformMatrix4fv("viewNormal",b.viewInvTransp);d.screenSizePerspective&&g.bindCamPos(c,b.viewInvTransp,a);d.instancedDoublePrecision&&
g.bindViewOriginDouble(c,a)};c.prototype.bindInstance=function(a,b){a=this.program;a.setUniformMatrix4fv("model",b.transformation);a.setUniformMatrix4fv("modelNormal",b.transformationNormal)};c.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return c}(t),ha=function(f){function c(a,b,d,c){void 0===c&&(c=!1);d=f.call(this,a,b,d,a.getParams().textureId)||this;d.params=g.copyParameters(a.getParams());d.instanced=p&&!!d.params.instanced;d.texturing=v.hasAttribute(a.getVertexBufferLayout(),"uv0")?
"Textured":"none";d.program=b.getShaderVariationsProgram(R,[d.texturing,d.params.flipV,d.instanced,d.params.instancedDoublePrecision,d.params.vvSizeEnabled,null!==d.params.verticalOffset,null!==d.params.screenSizePerspective,d.params.transparent,A]);d.slot=n(d.params.transparent,d.params.writeStencil);return d}l(c,f);c.prototype.beginSlot=function(a){return a===this.slot};c.prototype.getProgram=function(){return this.program};c.prototype.updateParameters=function(){var a=this.material.getParams(),
b=this.params;b.cullFace=a.cullFace;b.inverseWindingOrder=a.inverseWindingOrder;b.flipV=a.flipV;z(b,a);this.updateTexture(a.textureId);b.instancedDoublePrecision=a.instancedDoublePrecision};c.prototype.bind=function(a,b){var d=a.gl,c=this.program,f=this.params;a.bindProgram(c);this.bindTexture(a,c);g.bindVerticalOffset(f.verticalOffset,b,c);g.bindScreenSizePerspective(f.screenSizePerspective,c);y(c,f);w(a,f);f.inverseWindingOrder&&a.setFrontFace(d.CW);a.setDepthTestEnabled(!0)};c.prototype.release=
function(a){var b=a.gl,c=this.params;x(a,c);c.inverseWindingOrder&&a.setFrontFace(b.CW)};c.prototype.bindView=function(a,b){a=this.program;var c=this.params,e=c.instancedDoublePrecision?[b.viewInvTransp[3],b.viewInvTransp[7],b.viewInvTransp[11]]:b.origin;g.bindView(e,b.view,a);c.screenSizePerspective&&g.bindCamPos(e,b.viewInvTransp,a);c.instancedDoublePrecision&&g.bindViewOriginDouble(e,a)};c.prototype.bindInstance=function(a,b){a=this.program;a.setUniformMatrix4fv("model",b.transformation);a.setUniformMatrix4fv("modelNormal",
b.transformationNormal)};c.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return c}(t),Z={textureId:void 0,ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],externalColor:[1,1,1,1],colorMixMode:"multiply",opacity:1,layerOpacity:1,blendModeOneOne:!1,inverseWindingOrder:!1,vertexColors:!1,symbolColors:!1,componentIndices:!1,componentColorBuffer:null,flipV:!1,doubleSided:!1,doubleSidedType:"normal",cullFace:void 0,instanced:void 0,instancedDoublePrecision:!1,compressedNormals:!1,groundNormalShading:!1,
writeStencil:!1,receiveSSAO:!0,castShadows:!0,verticalOffset:null,screenSizePerspective:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvSizeValue:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],vvSymbolAnchor:[0,0,0],vvSymbolRotation:[0,0,0],transparent:!1,polygonOffset:!1,atlasRegions:!1},p,A=!!T("enable-feature:skallweit/lod-rendering"),O=
"material",P="material-depth",Q="material-normal",R="material-highlight",S=J.create(),Y=K.create(),I=C.create(),ca=h.create(),da=h.create(),ba=h.createFrom(0,0,1),M=h.create(),E=h.create(),D=h.create(),aa=h.create();return F});