// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/lib/edgeRendering/EdgeRenderer.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdgeStyleOutputs"\x3e\x3c![CDATA[\r\n#if defined(SKETCH) || defined(UBER)\r\n\r\n  uniform vec2 uStrokesTextureScale;\r\n  uniform float uStrokesLog2Resolution;\r\n  uniform float uStrokeVariants;\r\n\r\n  varying vec2 vStrokeUV;\r\n  varying float vLineIndex;\r\n\r\n  void calculateStyleOutputsSketch(float lineLength, UnpackedAttributes unpackedAttributes) {\r\n    vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\r\n\r\n    float lineIndex \x3d clamp(ceil(log2(lineLength)), 0.0, uStrokesLog2Resolution);\r\n\r\n    vStrokeUV \x3d vec2(exp2(lineIndex) * sidenessNorm.y, lineIndex * uStrokeVariants + aVariantStroke + 0.5) * uStrokesTextureScale;\r\n    vStrokeUV.x +\x3d aVariantOffset;\r\n\r\n    vLineIndex \x3d lineIndex;\r\n  }\r\n#endif /* SKETCH || UBER */\r\n\r\n#if defined(SKETCH)\r\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n    calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\r\n  }\r\n#elif defined(SOLID)\r\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n  }\r\n#elif defined(UBER)\r\n  varying float vType;\r\n\r\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n    vType \x3d unpackedAttributes.type;\r\n\r\n    if (unpackedAttributes.type \x3c\x3d 0.0) {\r\n      calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\r\n    }\r\n  }\r\n#endif /* UBER */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdgeLineAmplitudeRegular"\x3e\x3c![CDATA[\r\n\r\n#if defined(UBER) || !defined(SKETCH)\r\n\r\n  float calculateLineAmplitudeRegular() {\r\n    return 0.0;\r\n  }\r\n\r\n#endif /* UBER || !SKETCH */\r\n\r\n#if !defined(UBER) \x26\x26 !defined(SKETCH)\r\n\r\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\r\n    return calculateLineAmplitudeRegular();\r\n  }\r\n\r\n#endif /* !UBER \x26\x26 !SKETCH */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdgeLineAmplitudeSketch"\x3e\x3c![CDATA[\r\n\r\n#if defined(UBER) || defined(SKETCH)\r\n\r\n  uniform float uStrokesAmplitude;\r\n\r\n  float calculateLineAmplitudeSketch() {\r\n    return uStrokesAmplitude;\r\n  }\r\n\r\n#endif /* UBER || SKETCH */\r\n\r\n#ifdef SKETCH\r\n\r\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\r\n    return calculateLineAmplitudeSketch();\r\n  }\r\n\r\n#endif /* SKETCH */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdgeLineAmplitudeUber"\x3e\x3c![CDATA[\r\n\r\n#ifdef UBER\r\n\r\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\r\n    float type \x3d unpackedAttributes.type;\r\n\r\n    if (type \x3c\x3d 0.0) {\r\n      return calculateLineAmplitudeSketch();\r\n    }\r\n    else {\r\n      return calculateLineAmplitudeRegular();\r\n    }\r\n  }\r\n\r\n#endif /* UBER */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsRibbonEdge"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  // Transformations\r\n  uniform mat4 uProj;\r\n  uniform mat4 uView;\r\n  uniform mat4 uModel;\r\n  uniform vec3 uCameraPosition;\r\n\r\n  // Line configuration\r\n\r\n  // Conversion constants\r\n  uniform vec2 uPixelToNDC;\r\n  uniform vec2 uNDCToPixel;\r\n\r\n  // Inputs\r\n  attribute vec3 aPosition0;\r\n  attribute vec3 aPosition1;\r\n  attribute float aVariantOffset;\r\n  attribute float aVariantStroke;\r\n  attribute float aVariantExtension;\r\n\r\n#ifdef SILHOUETTE\r\n\r\n  attribute vec3 aNormalA;\r\n  attribute vec3 aNormalB;\r\n\r\n#else /* SILHOUETTE */\r\n\r\n  attribute vec3 aNormal;\r\n\r\n#endif /* SILHOUETTE */\r\n\r\nattribute vec2 aSideness;\r\nattribute vec2 aPackedAttributes;\r\n\r\nstruct UnpackedAttributes {\r\n  vec2 sideness;\r\n  vec2 sidenessNorm;\r\n  float lineWidthPixels;\r\n  float extensionLengthPixels;\r\n\r\n#ifdef UBER\r\n\r\n  float type;\r\n\r\n#endif\r\n};\r\n\r\n  // Output required to compute color\r\n  varying vec4 vColor;\r\n\r\n  // Output required to compute distance to line/caps\r\n  varying vec3 vPosition;\r\n  varying float vRadius;\r\n  varying float vLineLengthPixels;\r\n  varying float vSizeFalloffFactor;\r\n\r\n  $EdgeRendererUtils_adjustProjectedPosition\r\n\r\n  $vsRibbonEdgeStyleOutputs\r\n\r\n  $vsRibbonEdgeLineAmplitudeRegular\r\n  $vsRibbonEdgeLineAmplitudeSketch\r\n  $vsRibbonEdgeLineAmplitudeUber\r\n\r\n  $EdgeRendererUtils_readComponentData\r\n  $EdgeRendererUtils_distanceBasedPerspectiveFactor\r\n  $EdgeRendererUtils_worldNormal\r\n  $EdgeRendererUtils_extensionFalloff\r\n\r\n#ifdef SILHOUETTE\r\n\r\n  $EdgeRendererUtils_isSilhouetteEdge\r\n\r\n#endif /* SILHOUETTE */\r\n\r\n  vec4 calculateGeometricOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n    vec2 sideness \x3d unpackedAttributes.sideness;\r\n    vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\r\n\r\n    vec4 viewPos \x3d mix(viewPosV0, viewPosV1, sidenessNorm.y);\r\n    vec4 projPosV0 \x3d uProj * viewPosV0;\r\n    vec4 projPosV1 \x3d uProj * viewPosV1;\r\n    vec4 projPos \x3d uProj * viewPos;\r\n\r\n    vec3 screenSpaceLineNDC \x3d (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\r\n    vec2 screenSpaceLinePixels \x3d screenSpaceLineNDC.xy * uNDCToPixel;\r\n    float lineLengthPixels \x3d length(screenSpaceLinePixels);\r\n\r\n    float dzPerPixel \x3d screenSpaceLineNDC.z / lineLengthPixels;\r\n    vec2 screenSpaceDirection \x3d screenSpaceLinePixels / lineLengthPixels;\r\n    vec2 perpendicularScreenSpaceDirection \x3d vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\r\n\r\n    float falloffFactor \x3d distanceBasedPerspectiveFactor(-viewPos.z);\r\n    float lineWidthPixels \x3d unpackedAttributes.lineWidthPixels * falloffFactor;\r\n\r\n    float extensionLengthPixels \x3d calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\r\n    float lineAmplitudePixels \x3d calculateLineAmplitude(unpackedAttributes);\r\n\r\n    vSizeFalloffFactor \x3d falloffFactor;\r\n\r\n    float lineWidthAndAmplitudePixels \x3d lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\r\n    float extendedLineLengthPixels \x3d lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\r\n\r\n#ifdef ANTIALIASING\r\n\r\n    const float aaPaddingPixels \x3d 1.0;\r\n\r\n    // Line size with padding\r\n    float halfAAPaddedLineWidthAndAmplitudePixels \x3d lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\r\n    float aaPaddedRoundedCapSizePixels \x3d lineWidthPixels * 0.5 + aaPaddingPixels;\r\n\r\n    // Line length with padding\r\n    float aaPaddedLineLengthPixels \x3d extendedLineLengthPixels + aaPaddingPixels + aaPaddingPixels;\r\n    float halfAAPaddedLineLengthPixels \x3d aaPaddedLineLengthPixels * 0.5;\r\n\r\n#else /* ANTIALIASING */\r\n\r\n    // Even if there is no AA, we still want to do proper \x3c1px rendering,\r\n    // so we effectively clamp the pixel sizes to minimum of 1px and compute\r\n    // coverage in the fragment shader\r\n    float halfAAPaddedLineWidthAndAmplitudePixels \x3d max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\r\n    float aaPaddedRoundedCapSizePixels \x3d max(lineWidthPixels, 1.0) * 0.5;\r\n\r\n    float halfAAPaddedLineLengthPixels \x3d max(extendedLineLengthPixels, 1.0) * 0.5;\r\n\r\n#endif /* ANTIALIASING */\r\n\r\n    // Half line width in NDC including padding for anti aliasing\r\n    vec2 halfAAPaddedLineWidthAndAmplitudeNDC \x3d halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;\r\n    vec2 aaPaddedRoundedCapSizeNDC \x3d aaPaddedRoundedCapSizePixels * uPixelToNDC;\r\n    vec2 extensionLengthNDC \x3d extensionLengthPixels * uPixelToNDC;\r\n\r\n    // Compute screen space position of vertex, offsetting for line size and end caps\r\n    vec2 ndcOffset \x3d (\r\n        screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\r\n      + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\r\n    );\r\n\r\n    projPos.xy +\x3d ndcOffset * projPos.w;\r\n    projPos.z +\x3d (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\r\n\r\n    projPos \x3d adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\r\n\r\n    // Line length with end caps\r\n    float aaPaddedLineWithCapsLengthPixels \x3d extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\r\n\r\n    float pixelPositionAlongLine \x3d aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\r\n\r\n    // Position in pixels with origin at first vertex of line segment\r\n    vPosition \x3d vec3(\r\n      halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\r\n      pixelPositionAlongLine,\r\n      pixelPositionAlongLine / extendedLineLengthPixels\r\n    );\r\n\r\n    // The line width radius in pixels\r\n    vRadius \x3d lineWidthPixels * 0.5;\r\n    vLineLengthPixels \x3d extendedLineLengthPixels;\r\n\r\n#ifdef SILHOUETTE\r\n\r\n    gl_Position \x3d isSilhouetteEdge(viewPosV0, aNormalA, aNormalB) ? projPos : vec4(10, 10, 10, 1);\r\n\r\n#else /* SILHOUETTE */\r\n\r\n    gl_Position \x3d projPos;\r\n\r\n#endif /* SILHOUETTE */\r\n\r\n#ifdef UBER\r\n\r\n    if (unpackedAttributes.type \x3c\x3d 0.0 \x26\x26 lineLengthPixels \x3c\x3d 3.0) {\r\n      gl_Position \x3d vec4(10, 10, 10, 1);\r\n    }\r\n\r\n#elif defined(SKETCH)\r\n\r\n    if (lineLengthPixels \x3c\x3d 3.0) {\r\n      gl_Position \x3d vec4(10, 10, 10, 1);\r\n    }\r\n\r\n#endif\r\n\r\n    return projPos;\r\n  }\r\n\r\n#ifdef UBER\r\n\r\n  UnpackedAttributes unpackAttributes(ComponentData component) {\r\n\r\n    vec2 sidenessNorm \x3d aSideness;\r\n    vec2 sideness \x3d sidenessNorm * 2.0 - 1.0;\r\n\r\n    float fType \x3d component.type;\r\n    float extensionLengthPixels \x3d component.extensionLength;\r\n    float lineWidth \x3d component.lineWidth;\r\n\r\n    if (fType \x3c\x3d 0.0) {\r\n      extensionLengthPixels *\x3d aVariantExtension * 2.0 - 1.0;\r\n    }\r\n\r\n    return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels, fType);\r\n  }\r\n\r\n#else /* UBER */\r\n\r\n  UnpackedAttributes unpackAttributes(ComponentData component) {\r\n    vec2 sidenessNorm \x3d aSideness;\r\n    vec2 sideness \x3d sidenessNorm * 2.0 - 1.0;\r\n    float extensionLengthPixels \x3d component.extensionLength;\r\n\r\n#ifdef SKETCH\r\n\r\n    extensionLengthPixels *\x3d aVariantExtension * 2.0 - 1.0;\r\n\r\n#endif /* SKETCH */\r\n\r\n    float lineWidth \x3d component.lineWidth;\r\n\r\n    return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);\r\n  }\r\n\r\n#endif /* UBER */\r\n\r\n  void main() {\r\n    ComponentData component \x3d readComponentData();\r\n    UnpackedAttributes unpackedAttributes \x3d unpackAttributes(component);\r\n\r\n    vec4 worldPosV0 \x3d uModel * vec4(aPosition0, 1.0);\r\n    vec4 worldPosV1 \x3d uModel * vec4(aPosition1, 1.0);\r\n\r\n    vec4 viewPosV0 \x3d uView * worldPosV0;\r\n    vec4 viewPosV1 \x3d uView * worldPosV1;\r\n\r\n#ifdef SILHOUETTE\r\n\r\n    vec3 worldNormal \x3d silhouetteWorldNormal(aNormalA, aNormalB);\r\n\r\n#else /* SILHOUETTE */\r\n\r\n    vec3 worldNormal \x3d modelToWorldNormal(aNormal);\r\n\r\n#endif /* SILHOUETTE */\r\n\r\n    // General geometric computation for all types of edges\r\n    vec4 projPos \x3d calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal, unpackedAttributes);\r\n\r\n    // Component color\r\n    vColor \x3d component.color;\r\n\r\n    // Specific computation for different edge styles\r\n    calculateStyleOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, projPos, worldNormal, unpackedAttributes);\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdgeLineOffsetSketch"\x3e\x3c![CDATA[\r\n\r\n$rgba2float\r\n\r\n#if defined(UBER) || defined(SKETCH)\r\n\r\n  uniform sampler2D uStrokesTexture;\r\n  uniform float uStrokesNormalizationScale;\r\n\r\n  varying vec2 vStrokeUV;\r\n\r\n  float calculateLineOffsetSketch() {\r\n    float offsetNorm \x3d rgba2float(texture2D(uStrokesTexture, vStrokeUV));\r\n    return (offsetNorm - 0.5) * uStrokesNormalizationScale;\r\n  }\r\n\r\n  float calculateLinePressureSketch() {\r\n    return rgba2float(texture2D(uStrokesTexture, vStrokeUV + vec2(0, 0.5)));\r\n  }\r\n\r\n#endif /* UBER || SKETCH */\r\n\r\n#ifdef SKETCH\r\n\r\n  float calculateLineOffset() {\r\n    return calculateLineOffsetSketch();\r\n  }\r\n\r\n  float calculateLinePressure() {\r\n    return calculateLinePressureSketch();\r\n  }\r\n\r\n#endif /* SKETCH */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdgeLineOffsetRegular"\x3e\x3c![CDATA[\r\n\r\n#if defined(UBER) || !defined(SKETCH)\r\n\r\n  float calculateLineOffsetRegular() {\r\n    return 0.0;\r\n  }\r\n\r\n  float calculateLinePressureRegular() {\r\n    return 1.0;\r\n  }\r\n\r\n#endif /* UBER || !SKETCH */\r\n\r\n#if !defined(UBER) \x26\x26 !defined(SKETCH)\r\n\r\n  float calculateLineOffset() {\r\n    return calculateLineOffsetRegular();\r\n  }\r\n\r\n  float calculateLinePressure() {\r\n    return calculateLinePressureRegular();\r\n  }\r\n\r\n#endif /* !UBER || !SKETCH */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdgeLineOffsetUber"\x3e\x3c![CDATA[\r\n\r\n#ifdef UBER\r\n  varying float vType;\r\n\r\n  float calculateLineOffset() {\r\n    if (vType \x3c\x3d 0.0) {\r\n      return calculateLineOffsetSketch();\r\n    }\r\n    else {\r\n      return calculateLineOffsetRegular();\r\n    }\r\n  }\r\n\r\n  float calculateLinePressure() {\r\n    if (vType \x3c\x3d 0.0) {\r\n      return calculateLinePressureSketch();\r\n    }\r\n    else {\r\n      return calculateLinePressureRegular();\r\n    }\r\n  }\r\n#endif /* UBER */\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsRibbonEdge"\x3e\x3c![CDATA[\r\n  $fsprecisionf\r\n\r\n  varying vec4 vColor;\r\n  varying float vRadius;\r\n  varying vec3 vPosition;\r\n  varying float vLineLengthPixels;\r\n  varying float vSizeFalloffFactor;\r\n  varying float vLineIndex;\r\n\r\n  // At which coverage threshold we discard a fragment completely\r\n  #define COVERAGE_TEST_THRESHOLD 0.01\r\n\r\n  $fsRibbonEdgeLineOffsetRegular\r\n  $fsRibbonEdgeLineOffsetSketch\r\n  $fsRibbonEdgeLineOffsetUber\r\n\r\n  vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\r\n    float lineOffset \x3d calculateLineOffset();\r\n    float positionX \x3d position.x - lineOffset;\r\n\r\n    if (radius \x3c 1.0) {\r\n      // Handle this specifically for subpixel sizes:\r\n      // 1. Compute correct coverage (note coverage is computed by\r\n      //    0.5 - dist, so we make sure that that will lead to correct\r\n      //    subpixel coverage\r\n      // 2. Ignore rounded caps\r\n      float coverageX \x3d clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\r\n      float coverageY \x3d clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\r\n\r\n      float coverage \x3d min(coverageX, coverageY);\r\n\r\n      return vec2(0.5 - coverage, 0.0);\r\n    }\r\n    else {\r\n      // Between -radius -\x3e 0 for start cap, 0 for line, 0 -\x3e radius\r\n      float positionOnCap \x3d position.y - clamp(position.y, 0.0, lineLength);\r\n\r\n      vec2 lineToPosition \x3d vec2(positionX, positionOnCap);\r\n      return vec2(length(lineToPosition) - radius, positionOnCap / radius);\r\n    }\r\n  }\r\n\r\n  void main() {\r\n\r\n    float radius \x3d vRadius * calculateLinePressure();\r\n\r\n    vec2 distance \x3d lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\r\n    float coverage \x3d clamp(0.5 - distance.x, 0.0, 1.0);\r\n\r\n#ifdef ANTIALIASING\r\n\r\n    const float coverageLimit \x3d COVERAGE_TEST_THRESHOLD;\r\n\r\n#else /* ANTIALIASING */\r\n\r\n    // Use subpixel coverage computation when lines get subpixel widths\r\n    // so we still render them appropriately. Otherwise discard anything\r\n    // that is not fully within the line\r\n    float coverageLimit \x3d radius \x3c\x3d 0.5 ? COVERAGE_TEST_THRESHOLD : 0.75;\r\n\r\n#endif /* ANTIALIASING */\r\n\r\n    if (coverage \x3c coverageLimit) {\r\n      discard;\r\n    }\r\n\r\n    float alpha \x3d vColor.a * coverage;\r\n\r\n    gl_FragColor \x3d vec4(vColor.rgb, alpha);\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n',
"url:esri/views/3d/webgl-engine/lib/edgeRendering/EdgeRendererUtils.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"EdgeRendererUtils_distanceBasedPerspectiveFactor"\x3e\x3c![CDATA[\r\n  uniform float uDistanceFalloffFactor;\r\n\r\n  float distanceBasedPerspectiveFactor(float distance) {\r\n    return clamp(sqrt(uDistanceFalloffFactor / distance), 0.0, 1.0);\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"EdgeRendererUtils_readComponentData"\x3e\x3c![CDATA[\r\n  uniform sampler2D uComponentDataTex;\r\n  uniform vec2 uComponentDataTexInvDim;\r\n\r\n  attribute float aComponentIndex;\r\n\r\n  #define COMPONENT_COLOR_FIELD_OFFSET 0.0\r\n  #define COMPONENT_OTHER_FIELDS_OFFSET 1.0\r\n  #define COMPONENT_FIELD_COUNT 2.0\r\n\r\n  #define LINE_WIDTH_FRACTION_FACTOR 8.0\r\n  #define EXTENSION_LENGTH_OFFSET 128.0\r\n\r\n  #define COMPONENT_TEX_WIDTH 4096.0\r\n\r\n  vec2 componentTextureCoords(float componentIndex, float fieldOffset) {\r\n    float fieldIndex \x3d COMPONENT_FIELD_COUNT * componentIndex + fieldOffset;\r\n\r\n    float rowIndex \x3d floor(fieldIndex / COMPONENT_TEX_WIDTH);\r\n    float colIndex \x3d mod(fieldIndex, COMPONENT_TEX_WIDTH);\r\n\r\n    vec2 linearIndex \x3d vec2(\r\n      (colIndex + 0.5) / COMPONENT_TEX_WIDTH,\r\n      (rowIndex + 0.5) * uComponentDataTexInvDim.y\r\n    );\r\n\r\n    return linearIndex;\r\n  }\r\n\r\n  struct ComponentData {\r\n    vec4 color;\r\n    float lineWidth;\r\n    float extensionLength;\r\n    float type;\r\n  };\r\n\r\n  ComponentData readComponentData() {\r\n    vec2 colorIndex \x3d componentTextureCoords(aComponentIndex, COMPONENT_COLOR_FIELD_OFFSET);\r\n    vec2 otherIndex \x3d componentTextureCoords(aComponentIndex, COMPONENT_OTHER_FIELDS_OFFSET);\r\n\r\n    vec4 colorValue \x3d texture2D(uComponentDataTex, colorIndex);\r\n    vec4 otherValue \x3d texture2D(uComponentDataTex, otherIndex);\r\n\r\n    return ComponentData(\r\n      vec4(colorValue.rgb, colorValue.a * otherValue.w), // otherValue.w stores separate opacity\r\n      otherValue.x * (255.0 / LINE_WIDTH_FRACTION_FACTOR),\r\n      otherValue.y * 255.0 - EXTENSION_LENGTH_OFFSET,\r\n      -(otherValue.z * 255.0) + 0.5 // SOLID (\x3d0/255) needs to be \x3e 0.0, SKETCHY (\x3d1/255) needs to be \x3c\x3d 0;\r\n    );\r\n  }\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"EdgeRendererUtils_isSilhouetteEdge"\x3e\x3c![CDATA[\r\n  // #uniforms: uView, uModel\r\n  bool isSilhouetteEdge(vec4 viewPos, vec3 normalA, vec3 normalB) {\r\n    // transform the two face normals\r\n    vec3 viewNormalA \x3d (uView * uModel * vec4(normalA, 0.0)).xyz;\r\n    vec3 viewNormalB \x3d (uView * uModel * vec4(normalB, 0.0)).xyz;\r\n\r\n    // compute the direction from the edge to the camera\r\n    vec3 viewDir \x3d -viewPos.xyz;\r\n\r\n    // check which of the two faces are visible\r\n    // display the edge if exactly one of the two is visible\r\n    float faceAVisible \x3d dot(viewDir, viewNormalA); // positive if visible\r\n    float faceBVisible \x3d dot(viewDir, viewNormalB); // positive if visible\r\n\r\n    // 1 if exactly one face visible, 0 otherwise\r\n    return faceAVisible * faceBVisible \x3c 0.0;\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"EdgeRendererUtils_adjustProjectedPosition"\x3e\x3c![CDATA[\r\n  uniform vec2 uDepthBias;\r\n  uniform vec2 uViewportDimInv;\r\n\r\n  // Utility function to check for NaN values\r\n  bool isNaN(float val) {\r\n    return ( val \x3c 0.0 || 0.0 \x3c val || val \x3d\x3d 0.0 ) ? false : true;\r\n    // important: some nVidias failed to cope with version below.\r\n    // Probably wrong optimization.\r\n    /*return ( val \x3c\x3d 0.0 || 0.0 \x3c\x3d val ) ? false : true;*/\r\n  }\r\n\r\n  // An offset in xy screen space, along the projected normal of the edge\r\n  // This reduces depth fighting when looking at a face from a flat angle\r\n  vec2 calculateProjectedBiasXY(vec4 projPos, vec3 worldNormal) {\r\n    float offsetXY \x3d uDepthBias.x;\r\n    float offsetZ  \x3d uDepthBias.y;\r\n\r\n    // screen space pixel offset\r\n    // we multiply by two to account for the fact that NDC go from -1 to 1\r\n    // we multiply by projPos.w to compensate for the perspective divison that happens later\r\n    // normalizing over xyz means that the xy influence is reduced the more the normal is pointing\r\n    // towards the camera\r\n    vec4 projNormal \x3d uProj * uView * vec4(worldNormal, 0.0);\r\n\r\n    return offsetXY * projPos.w * 2.0 * uViewportDimInv * normalize(projNormal.xyz).xy;\r\n  }\r\n\r\n  // A z-offset, using a depth based heuristic.\r\n  float calculateProjectedBiasZ(vec4 projPos) {\r\n    float offsetZ \x3d uDepthBias.y;\r\n    return sqrt(projPos.z) * offsetZ;\r\n  }\r\n\r\n  vec4 adjustProjectedPosition(vec4 projPos, vec3 worldNormal, float lineWidth) {\r\n    vec2 offsetXY \x3d calculateProjectedBiasXY(projPos, worldNormal);\r\n\r\n    // we currently have to do this check because some geometries come with 0 length edge normals.\r\n    // see https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/12890\r\n    if (!isNaN(offsetXY.x) \x26\x26 !isNaN(offsetXY.y)) {\r\n      projPos.xy +\x3d offsetXY;\r\n    }\r\n\r\n    projPos.z +\x3d calculateProjectedBiasZ(projPos);\r\n\r\n    return projPos;\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"EdgeRendererUtils_worldNormal"\x3e\x3c![CDATA[\r\n  vec3 modelToWorldNormal(vec3 normal) {\r\n    return (uModel * vec4(normal, 0)).xyz;\r\n  }\r\n\r\n  vec3 silhouetteWorldNormal(vec3 normalA, vec3 normalB) {\r\n    return modelToWorldNormal(normalize(normalA + normalB));\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"EdgeRendererUtils_extensionFalloff"\x3e\x3c![CDATA[\r\n  // Fall-off extension length for shorter strokes, starting from strokes that are 256 size,\r\n  // fall-off exponentially\r\n  float calculateExtensionLength(float extensionLength, float lineLength) {\r\n    return extensionLength / (log2(max(1.0, 256.0 / lineLength)) * 0.2 + 1.0);\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("require exports ../../../../../core/tsSupport/assignHelper ../../../../../core/tsSupport/extendsHelper dojo/text!./EdgeRenderer.xml dojo/text!./EdgeRendererUtils.xml ../../../lib/glMatrix ../../../support/mathUtils ../ShaderVariations ./bufferLayouts".split(" "),function(g,d,l,u,m,n,h,p,q,k){Object.defineProperty(d,"__esModule",{value:!0});d.LINE_WIDTH_FRACTION_FACTOR=8;d.EXTENSION_LENGTH_OFFSET=128;var r={type:"solid",uber:!0,strokesTexture:null},t=function(){function b(){this._value=0}Object.defineProperty(b.prototype,
"value",{get:function(){return this._value},enumerable:!0,configurable:!0});b.prototype.increment=function(){this._value++};b.prototype.decrement=function(){this._value--};return b}();g=function(){function b(a,c,f){this.rctx=a;this.programRepository=c;this.refCount=new t;this.renderables=new Set;this.depthBiasZ=-4E-4;this.depthBiasXY=.5;this.tmpViewToWorldNormalMatrix=h.mat3d.create();this.settings=l({},r,f);this.key=b.getKey(this.settings.uber,this.settings.type);this.writerSettings={variants:this.settings.strokesTexture.variants};
this.createPrograms()}b.prototype.dispose=function(){for(var a in this.programs){var c=this.programs[a];c&&(this.programRepository.decreaseRefCount(c),this.programs[a]=null)}};b.prototype.addRenderable=function(a){this.renderables.add(a)};b.prototype.removeRenderable=function(a){this.renderables.delete(a)};b.prototype.forEachRenderable=function(a){this.renderables.forEach(a)};b.prototype.bindRegularEdges=function(a,c){this.bind(this.programs.regular,a,c)};b.prototype.bindSilhouetteEdges=function(a,
c){this.bind(this.programs.silhouette,a,c)};b.prototype.bind=function(a,c,b){this.rctx.bindProgram(a);a.setUniformMatrix4fv("uProj",c.proj);a.setUniform2f("uDepthBias",this.depthBiasXY,this.depthBiasZ);a.setUniform2f("uPixelToNDC",2/c.viewport[2],2/c.viewport[3]);a.setUniform2f("uNDCToPixel",c.viewport[2]/2,c.viewport[3]/2);a.setUniform1f("uDistanceFalloffFactor",b.distanceFalloffFactor);a.setUniform2f("uViewportDimInv",1/c.viewport[2],1/c.viewport[3])};b.prototype.renderRegularEdges=function(a,c,
b){this.render(this.programs.regular,a,a.regular.vao,c,b)};b.prototype.renderSilhouetteEdges=function(a,c,b){this.render(this.programs.silhouette,a,a.silhouette.vao,c,b)};b.prototype.render=function(a,c,b,d,e){this.setUniforms(a,c,d);a=this.rctx;a.bindVAO(b);a.capabilities.instancing.drawArraysInstanced(6,0,4,e)};b.prototype.setUniforms=function(a,c,b){c.components.buffer.textureBuffer.bind(a,d.componentDataBindParameters);a.setUniformMatrix4fv("uView",b.view);a.setUniformMatrix4fv("uModel",c.transform.modelMatrix);
var f=b.viewInvTransp,e=h.mat4d.toMat3(f,this.tmpViewToWorldNormalMatrix);a.setUniform3f("uCameraPosition",f[3],f[7],f[11]);a.setUniformMatrix3fv("uViewToWorldNormalMatrix",e);(this.settings.uber||"sketch"===this.settings.type)&&this.setSketchUniforms(a);a.setUniform1f("uWorldLineRadiusPerDistance",Math.tan(b.fovY/2)/(b.viewport[3]/2));a.setUniform3fv("uLocalOrigin",c.transform.origin.vec3)};b.prototype.setSketchUniforms=function(a){var c=this.settings.strokesTexture,b=c.texture;this.rctx.bindTexture(b,
0);a.setUniform1i("uStrokesTexture",0);a.setUniform2f("uStrokesTextureScale",1/b.descriptor.width,1/b.descriptor.height);a.setUniform1f("uStrokesLog2Resolution",p.log2(c.resolution));a.setUniform1f("uStrokesNormalizationScale",c.normalizationScale);a.setUniform1f("uStrokesAmplitude",c.amplitude);a.setUniform1f("uStrokeVariants",c.variants)};b.prototype.getDefines=function(a){return[a.silhouette,!!this.rctx.capabilities.blendMinMax,"solid"===this.settings.type&&!this.settings.uber,"sketch"===this.settings.type&&
!this.settings.uber,this.settings.uber]};b.prototype.createPrograms=function(){var a=this.programRepository.getShaderVariationsProgram(e,this.getDefines({silhouette:!1}),void 0,void 0,k.EdgeShaderAttributeLocations),c=this.programRepository.getShaderVariationsProgram(e,this.getDefines({silhouette:!0}),void 0,void 0,k.EdgeShaderAttributeLocations);this.programRepository.increaseRefCount(a);this.programRepository.increaseRefCount(c);this.programs={regular:a,silhouette:c}};b.loadShaders=function(a,c,
b){a.EdgeRendererUtils_readComponentColor||a._parse(n);a.fsRibbonEdge||a._parse(m);c.getShaderVariations(e)||(a=new q("ribbonEdge",["vsRibbonEdge","fsRibbonEdge"],null,c,a,b),a.addDefine("Silhouette","SILHOUETTE"),a.addDefine("AntiAliasing","ANTIALIASING"),a.addDefine("Solid","SOLID"),a.addDefine("Sketch","SKETCH"),a.addDefine("Uber","UBER"),c.addShaderVariations(e,a))};b.getKey=function(a,b){return a?"edges-uber":"edges-t:"+b};return b}();d.EdgeRenderer=g;var e="edge-shader-variations";d.componentDataBindParameters=
{texName:"uComponentDataTex",invDimName:"uComponentDataTexInvDim",unit:2}});