// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/interactive/measurementTools/directLineMeasurement3D/LaserLine.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"fsLaserLine"\x3e\x3c![CDATA[\r\n  $enableRequiredExtensions\r\n  $fsprecisionf\r\n\r\n  varying vec2 uv;\r\n\r\n  uniform sampler2D depthMap;\r\n\r\n  uniform vec2 nearFar;\r\n  uniform vec4 projInfo;\r\n  uniform vec2 zScale;\r\n  uniform float maxPixelDistance;\r\n\r\n  // focus plane in camera space\r\n  uniform vec4 focusPlane;\r\n\r\n  // focus sphere in camera space\r\n  uniform vec4 focusSphere;\r\n\r\n  // segment plane in camera space\r\n  uniform vec4 segmentPlane;\r\n\r\n  // line segment\r\n  uniform vec3 segmentStart;\r\n  uniform vec3 segmentEnd;\r\n\r\n  // styling\r\n  uniform vec3 glowColor;\r\n  uniform float glowWidth;\r\n  uniform vec3 innerColor;\r\n  uniform float innerWidth;\r\n  uniform float globalAlpha;\r\n\r\n  #define INFINITY 100000.0\r\n\r\n  $rgba2float\r\n\r\n  // reconstruct depth value from linear depth map\r\n  float linearDepth(vec2 uv) {\r\n    return -(rgba2float(texture2D(depthMap, uv)) * (nearFar[1] - nearFar[0]) + nearFar[0]);\r\n  }\r\n\r\n  // reconstruct position in view space\r\n  vec3 reconstructPosition(vec2 fragCoord, float depth) {\r\n    return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);\r\n  }\r\n\r\n  float planeDistancePixels(vec4 plane, vec3 pos) {\r\n    // compute distance to plane\r\n    float dist \x3d dot(plane.xyz, pos) + plane.w;\r\n    // compute derivative of distance function with respect to pixels\r\n    float width \x3d fwidth(dist);\r\n    // normalize distance by the derivative to get a measurement with respect to pixels\r\n    // the clamping is used to prevent excessive artifacts along depth discontinuities\r\n    dist /\x3d min(width, maxPixelDistance);\r\n    return abs(dist);\r\n  }\r\n\r\n  float sphereDistancePixels(vec4 sphere, vec3 pos) {\r\n    // compute distance to sphere\r\n    float dist \x3d distance(sphere.xyz, pos) - sphere.w;\r\n    // compute derivative of distance function with respect to pixels\r\n    float width \x3d fwidth(dist);\r\n    // normalize distance by the derivative to get a measurement with respect to pixels\r\n    // the clamping is used to prevent excessive artifacts along depth discontinuities\r\n    dist /\x3d min(width, maxPixelDistance);\r\n    return abs(dist);\r\n  }\r\n\r\n  vec4 blendPremultiplied(vec4 source, vec4 dest) {\r\n    float oneMinusSourceAlpha \x3d 1.0 - source.a;\r\n\r\n    return vec4(\r\n      source.rgb + dest.rgb * oneMinusSourceAlpha,\r\n      source.a + dest.a * oneMinusSourceAlpha\r\n    );\r\n  }\r\n\r\n  vec4 premultipliedColor(vec3 rgb, float alpha) {\r\n    return vec4(rgb * alpha, alpha);\r\n  }\r\n\r\n  // computes laser line color based on distance in pixels\r\n  vec4 laserLineProfile(float dist) {\r\n    if (dist \x3e glowWidth) {\r\n      return vec4(0.0);\r\n    }\r\n\r\n    float innerAlpha \x3d (1.0 - smoothstep(0.0, innerWidth, dist));\r\n    float glowAlpha \x3d pow(max(0.0, 1.0 - dist / glowWidth), 8.0);\r\n\r\n    return blendPremultiplied(\r\n      premultipliedColor(innerColor, innerAlpha),\r\n      premultipliedColor(glowColor, glowAlpha)\r\n    );\r\n  }\r\n\r\n  void main() {\r\n    // do not draw laserline on background\r\n    float depth \x3d linearDepth(uv);\r\n    if (-depth \x3d\x3d nearFar[0]) {\r\n      discard;\r\n    }\r\n\r\n    // reconstruct position in view space\r\n    vec3 pos \x3d reconstructPosition(gl_FragCoord.xy, depth);\r\n\r\n    // empirical hack to fade out laser line in problematic areas:\r\n    // the derivatives to normalize the distance function are valid inside smooth surfaces,\r\n    // but break down at depth discontinuities (e.g. edges). We fade out the laser lines in\r\n    // areas where depth valus have large variations in order to avoid this problem.\r\n    float ddepth \x3d fwidth(depth);\r\n    float depthDiscontinuityAlpha \x3d 1.0 - smoothstep(0.0, 0.01, -ddepth / depth);\r\n\r\n    // reconstruct normal using derivatives\r\n    vec3 normal \x3d normalize(cross(dFdx(pos), dFdy(pos)));\r\n\r\n    // distance to focus plane\r\n    float focusPlaneDistance \x3d planeDistancePixels(focusPlane, pos);\r\n\r\n    // distance to focus sphere\r\n    float focusSphereDistance \x3d sphereDistancePixels(focusSphere, pos);\r\n\r\n    // distance to segment plane\r\n    float segmentDistance \x3d INFINITY;\r\n    float segmentLength \x3d length(segmentEnd - segmentStart);\r\n    vec3 segmentDir \x3d (segmentEnd - segmentStart) / segmentLength;\r\n    float t \x3d dot(segmentDir, pos - segmentStart);\r\n\r\n    if (segmentLength \x3e 0.0 \x26\x26 t \x3e\x3d 0.0 \x26\x26 t \x3c\x3d segmentLength) {\r\n      segmentDistance \x3d planeDistancePixels(segmentPlane, pos);\r\n    }\r\n\r\n    // evaluate color profile for both planes and the sphere\r\n    vec4 focusPlaneColor \x3d laserLineProfile(focusPlaneDistance);\r\n    vec4 focusSphereColor \x3d laserLineProfile(focusSphereDistance);\r\n    vec4 segmentColor \x3d laserLineProfile(segmentDistance);\r\n\r\n    // empirical hack to fade out laser line when planes are nearly parallel\r\n    float focusPlaneAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, focusPlane.xyz)));\r\n    float focusSphereAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, normalize(pos - focusSphere.xyz))));\r\n    float segmentAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, segmentPlane.xyz)));\r\n\r\n    // combine colors\r\n    vec4 color \x3d max(\r\n      focusPlaneColor * focusPlaneAlpha,\r\n      max(\r\n        focusSphereColor * focusSphereAlpha,\r\n        segmentColor * segmentAlpha\r\n      )\r\n    );\r\n\r\n    gl_FragColor \x3d color * globalAlpha * depthDiscontinuityAlpha;\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("require exports ../../../../../core/tsSupport/extendsHelper dojo/text!./LaserLine.xml ../../../lib/glMatrix ../../../webgl-engine/lib/DefaultVertexAttributeLocations ../../../webgl-engine/lib/glUtil3D ../../../webgl-engine/lib/RenderSlot ../../../webgl-engine/lib/Util ../../../webgl-engine/materials/internal/MaterialUtil ../../../../webgl/Program".split(" "),function(B,C,D,t,a,u,v,w,x,p,y){function q(c,f,e,g){var r=l,b=z;a.mat4d.multiplyVec3(g,f,r);a.vec3d.set(e,b);b[3]=0;a.mat4d.multiplyVec4(g,
b);a.vec4d.set4(b[0],b[1],b[2],-a.vec3d.dot(b,r),c)}var l=a.vec3d.create(),z=a.vec4d.create(),A={glowColor:[1,.5,0],glowWidth:8,innerColor:[1,1,1],innerWidth:1,globalAlpha:.75};return function(){function c(f,e){void 0===e&&(e={});this._projInfo=a.vec4d.create();this._zScale=a.vec2d.create();this._segmentActive=this._focusSphereActive=this._focusPlaneActive=!1;this._focusPosition=a.vec3d.create();this._focusSpherePosition=a.vec3d.create();this._segmentStartPosition=a.vec3d.create();this._segmentEndPosition=
a.vec3d.create();this._needsRender=!1;this._tempNormal=a.vec3d.create();this._tempDir=a.vec3d.create();this._tempUp=a.vec3d.create();this._tempVec3=a.vec3d.create();this._tempVec4=a.vec4d.create();this.didRender=!1;this._renderCoordsHelper=f;this._params=p.copyParameters(e,A)}Object.defineProperty(c.prototype,"needsRender",{get:function(){return this._needsRender},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"renderSlots",{get:function(){return[w.POSTPROCESSING_EXTERNAL]},enumerable:!0,
configurable:!0});Object.defineProperty(c.prototype,"needsLinearDepth",{get:function(){return!0},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"focusPlaneActive",{get:function(){return this._focusPlaneActive},set:function(a){a!==this._focusPlaneActive&&(this._focusPlaneActive=a,this._needsRender=!0)},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"focusSphereActive",{get:function(){return this._focusSphereActive},set:function(a){a!==this._focusSphereActive&&
(this._focusSphereActive=a,this._needsRender=!0)},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"segmentActive",{get:function(){return this._segmentActive},set:function(a){a!==this._segmentActive&&(this._segmentActive=a,this._needsRender=!0)},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"focusPosition",{get:function(){return this._focusPosition},set:function(f){a.vec3d.set(f,this._focusPosition);this._needsRender=!0},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,
"focusSpherePosition",{get:function(){return this._focusSpherePosition},set:function(f){a.vec3d.set(f,this._focusSpherePosition);this._needsRender=!0},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"segmentStartPosition",{get:function(){return this._segmentStartPosition},set:function(f){a.vec3d.set(f,this._segmentStartPosition);this._needsRender=!0},enumerable:!0,configurable:!0});Object.defineProperty(c.prototype,"segmentEndPosition",{get:function(){return this._segmentEndPosition},
set:function(f){a.vec3d.set(f,this._segmentEndPosition);this._needsRender=!0},enumerable:!0,configurable:!0});c.prototype.setParameterValues=function(a){p.updateParameters(this._params,a)&&(this._needsRender=!0)};c.prototype.initializeRenderContext=function(a){var e=a.rctx;this._quadVAO=v.createQuadVAO(e);a.shaderSnippets.fsLaserLine||a.shaderSnippets._parse(t);this._laserLineProgram=new y(e,a.shaderSnippets.vsUVQuad,a.shaderSnippets.fsLaserLine,u.Default3D)};c.prototype.uninitializeRenderContext=
function(a){this._quadVAO.dispose();this._quadVAO=null;this._laserLineProgram.dispose();this._projInfo=this._laserLineProgram=null};c.prototype.resetNeedsRender=function(){this.didRender&&(this._needsRender=this.didRender=!1)};c.prototype.render=function(c){var e=c.rctx,g=c.camera,f=this._renderCoordsHelper,b=this._laserLineProgram,d=this._projInfo,h=this._zScale;e.bindProgram(b);x.inverseProjectionInfo(g.projectionMatrix,g.fullWidth,g.fullHeight,d,h);b.setUniform4fv("projInfo",d);b.setUniform2fv("zScale",
h);b.setUniform2f("nearFar",g.near,g.far);b.setUniform1f("maxPixelDistance",2*g.computePixelSizeAt(this._focusPosition));if(this._focusPlaneActive){var d=this._focusPosition,h=this._tempVec3,k=this._tempVec4;f.worldUpAtPosition(d,h);q(k,d,h,g.viewMatrix);b.setUniform4fv("focusPlane",k)}else b.setUniform4fv("focusPlane",[0,0,0,1E10]);this._focusSphereActive?(h=this._tempVec4,d=this._tempVec3,a.vec3d.set(this._focusSpherePosition,h),a.mat4d.multiplyVec3(g.viewMatrix,h),a.vec3d.set(this._focusPosition,
d),a.mat4d.multiplyVec3(g.viewMatrix,d),h[3]=a.vec3d.dist(h,d),b.setUniform4fv("focusSphere",h)):b.setUniform4fv("focusSphere",[0,0,0,1E10]);if(this._segmentActive){var d=this._tempVec4,h=this._tempVec3,k=this._tempUp,m=this._tempDir,n=this._tempNormal;a.vec3d.lerp(this._segmentStartPosition,this._segmentEndPosition,.5,h);f.worldUpAtPosition(h,k);a.vec3d.subtract(this._segmentEndPosition,this._segmentStartPosition,m);a.vec3d.normalize(m);a.vec3d.cross(k,m,n);a.vec3d.normalize(n);q(d,this._segmentStartPosition,
n,g.viewMatrix);b.setUniform4fv("segmentPlane",d)}else b.setUniform4fv("segmentPlane",[0,0,0,1E10]);d=l;a.vec3d.set(this._segmentStartPosition,d);f.setAltitude(0,d);a.mat4d.multiplyVec3(g.viewMatrix,d);b.setUniform3fv("segmentStart",d);d=l;a.vec3d.set(this._segmentEndPosition,d);f.setAltitude(0,d);a.mat4d.multiplyVec3(g.viewMatrix,d);b.setUniform3fv("segmentEnd",d);b.setUniform1i("depthMap",0);e.bindTexture(c.depth.colorTexture,0);b.setUniform3fv("innerColor",this._params.innerColor);b.setUniform1f("innerWidth",
this._params.innerWidth);b.setUniform3fv("glowColor",this._params.glowColor);b.setUniform1f("glowWidth",this._params.glowWidth);b.setUniform1f("globalAlpha",this._params.globalAlpha);e.bindVAO(this._quadVAO);e.setDepthTestEnabled(!1);e.setDepthWriteEnabled(!1);e.setBlendFunctionSeparate(1,771,770,771);e.setBlendingEnabled(!0);e.drawArrays(5,0,4);e.setDepthTestEnabled(!0);e.setDepthWriteEnabled(!0);e.setBlendingEnabled(!1);return!0};return c}()});