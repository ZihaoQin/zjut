// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.8/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/HUDMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUD"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  $commonAttributesAndUniformsHUD\r\n\r\n  uniform float pixelRatio;\r\n  uniform vec2 screenOffset;\r\n  uniform vec2 anchorPos;\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n  uniform vec4 screenSizePerspective;\r\n\r\n#endif\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n  varying vec3 debugBorderCoords;\r\n#endif\r\n\r\n  attribute vec2 $uv0;\r\n  attribute vec4 $color;\r\n  attribute vec2 $size;\r\n  attribute vec4 $auxpos2;\r\n\r\n  varying vec4 vcolor;\r\n\r\n  varying vec2 vtc;\r\n  varying vec2 vsize;\r\n\r\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\r\n  varying float voccluded;\r\n#endif\r\n\r\n  $vvUniforms\r\n\r\n  $alignToPixelCenter\r\n  $alignToPixelOrigin\r\n  $projectPositionHUD\r\n  $vvFunctions\r\n\r\n  void main(void) {\r\n    ProjectHUDAux projectAux;\r\n    vec4 posProj \x3d projectPositionHUD(projectAux);\r\n\r\n    vec2 inputSize;\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n    inputSize \x3d screenSizePerspectiveScaleVec2($size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\r\n\r\n    vec2 screenOffsetScaled \x3d screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\r\n\r\n#else\r\n\r\n    inputSize \x3d $size;\r\n\r\n    vec2 screenOffsetScaled \x3d screenOffset;\r\n#endif\r\n\r\n#ifdef VV_SIZE\r\n    // only use width (.xx) for proportional scaling\r\n    // (if no width was defined in vv, width\r\n    //  will be a copy of height vv)\r\n    inputSize *\x3d vvGetScale($auxpos2).xx;\r\n#endif\r\n\r\n    vec2 combinedSize \x3d inputSize * pixelRatio;\r\n    vec4 quadOffset \x3d vec4(0);\r\n\r\n#if defined(OCCL_TEST) || defined(BINARY_HIGHLIGHT_OCCLUSION)\r\n    bool visible \x3d testVisibilityHUD(posProj);\r\n#endif\r\n\r\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\r\n  voccluded \x3d visible ? 0.0 : 1.0;\r\n#endif\r\n\r\n#ifdef OCCL_TEST\r\n    if (visible) {\r\n#endif\r\n      // UV goes from 0 to 1.99999, where the integer part is used\r\n      // for the normalized vertex coordinates, and the fractional\r\n      // part is used for texture sampling\r\n      vec2 uv01 \x3d floor($uv0);\r\n      vec2 uv \x3d $uv0 - uv01;\r\n\r\n      // Displace icon based on anchor position (normalized for size) and\r\n      // absolute screen offset. anchorPos is [-0.5, 0.5]\r\n      quadOffset.xy \x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\r\n\r\n#ifdef SIGNED_DISTANCE_FIELD\r\n\r\n      // SDF primitives might be scaled so that the SDF texture resolution does\r\n      // not match the resolution of the canvas, but we still want to render\r\n      // outline-only (\'cross\' and \'x\') primitives cleanly. Aligning to a screen\r\n      // pixel border at the geometry center achieves this, since SDF textures\r\n      // always have power of 2 dimensions.\r\n      posProj \x3d alignToPixelOrigin(posProj, viewport.zw) + quadOffset;\r\n#else\r\n      posProj +\x3d quadOffset;\r\n\r\n      // Aligning vertex positions to the nearest (using \'floor\') screen pixel\r\n      // border renders textures with pixel-perfect results. If the texture\r\n      // resolution does not match the canvas resolution then aligning is\r\n      // redundant.\r\n      if (inputSize.x \x3d\x3d $size.x) {\r\n        posProj \x3d alignToPixelOrigin(posProj, viewport.zw);\r\n      }\r\n#endif\r\n\r\n      gl_Position \x3d posProj;\r\n\r\n      vtc \x3d uv;\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n      debugBorderCoords \x3d vec3(uv01, 1.0 / combinedSize);\r\n#endif\r\n\r\n      vsize \x3d inputSize;\r\n#ifdef OCCL_TEST\r\n    } else {\r\n      vtc \x3d vec2(.0);\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n      debugBorderCoords \x3d vec3(0);\r\n#endif\r\n\r\n    }\r\n#endif\r\n\r\n    gl_Position \x3d posProj;\r\n\r\n#ifdef VV_COLOR\r\n    vcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n    vcolor \x3d $color / 255.0;\r\n#endif\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDBaseVariables"\x3e\x3c![CDATA[\r\n  $enableRequiredExtensions\r\n  $fsprecisionf\r\n\r\n  uniform sampler2D tex;\r\n  uniform vec4 overrideColor;\r\n  uniform vec4 outlineColor;\r\n  uniform float outlineSize;\r\n\r\n  varying vec4 vcolor;\r\n\r\n  varying vec2 vtc;\r\n  varying vec2 vsize;\r\n\r\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\r\n  varying float voccluded;\r\n#endif\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n  varying vec3 debugBorderCoords;\r\n#endif\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDBaseMain"\x3e\x3c![CDATA[\r\n  vec4 premultiply(vec4 v) {\r\n    return vec4(v.rgb * v.a, v.a);\r\n  }\r\n\r\n  $rgba2float\r\n\r\n  void main() {\r\n\r\n#ifdef SIGNED_DISTANCE_FIELD\r\n    vec4 color \x3d vec4(0.0, 0.0, 0.0, 0.0);\r\n    vec4 fillPixelColor \x3d overrideColor * vcolor;\r\n\r\n    // Attempt to sample texel centers to avoid that thin cross outlines\r\n    // disappear with large symbol sizes.\r\n    // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\r\n    const float txSize \x3d 128.0;\r\n    const float texelSize \x3d 1.0 / txSize;\r\n    // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel\r\n    vec2 scaleFactor \x3d (vsize - txSize) * texelSize;\r\n    vec2 samplePos \x3d vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\r\n\r\n    // Get distance and map it into [-0.5, 0.5]\r\n    float d \x3d rgba2float(texture2D(tex, samplePos)) - 0.5;\r\n\r\n    // Distance in output units (i.e. pixels)\r\n    float dist \x3d d * vsize.x;\r\n\r\n    // Create smooth transition from the icon into its outline\r\n    fillPixelColor.a *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n    if (outlineSize \x3e 0.25) {\r\n      vec4 outlinePixelColor \x3d outlineColor;\r\n      float clampedOutlineSize \x3d min(outlineSize, 0.5*vsize.x);\r\n\r\n      // Create smooth transition around outline\r\n      outlinePixelColor.a *\x3d clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\r\n\r\n      // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\r\n      float compositeAlpha \x3d outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n      vec3 compositeColor \x3d vec3(outlinePixelColor) * outlinePixelColor.a +\r\n        vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\r\n      gl_FragColor \x3d vec4(compositeColor, compositeAlpha);\r\n    }\r\n    else {\r\n      gl_FragColor \x3d premultiply(fillPixelColor);\r\n    }\r\n\r\n    // visualize SDF:\r\n    // gl_FragColor \x3d vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\r\n#else\r\n\r\n    // HUDMaterial is rendered with a blending mode that assumes a pre-multiplied\r\n    // fragment color. Input textures should already be pre-multiplied and so\r\n    // don\'t require adjustment, but the override and vertex colors must be\r\n    // modulated by their alpha values.\r\n\r\n    gl_FragColor \x3d texture2D(tex, vtc, -0.5) * premultiply(overrideColor * vcolor);\r\n\r\n#endif\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n     float isBorder \x3d float(any(lessThan(debugBorderCoords.xy, vec2(debugBorderCoords.z))) || any(greaterThan(debugBorderCoords.xy, vec2(1.0 - debugBorderCoords.z))));\r\n     gl_FragColor \x3d mix(gl_FragColor, vec4(1, 0, 1, 1), isBorder);\r\n#endif\r\n\r\n    if (gl_FragColor.a \x3c 0.1) {\r\n      discard;\r\n    }\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUD"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBaseVariables\r\n$fragmentShaderHUDBaseMain\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDHighlight"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBaseVariables\r\n\r\n  uniform sampler2D depthTex;\r\n  uniform vec4 highlightViewportPixelSz;\r\n\r\n$fragmentShaderHUDBaseMain\r\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\r\n    // Instead of deciding on a per-pixel basis if the highlight is occluded,\r\n    // do it for all highlight pixel based on the centroid occlusion. This\r\n    // is a temporary solution for:\r\n    // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/9645\r\n    if (voccluded \x3d\x3d 1.0) {\r\n      gl_FragColor \x3d vec4(1.0, 1.0, 0.0, 1.0);\r\n    } else {\r\n      gl_FragColor \x3d vec4(1.0, 0.0, 1.0, 1.0);\r\n    }\r\n#else\r\n    $highlightWrite\r\n#endif\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderOcclusionTestPixel"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  $commonAttributesAndUniformsHUD\r\n\r\n  $alignToPixelCenter\r\n  $projectPositionHUD\r\n\r\n  void main(void) {\r\n    vec4 posProjCenter;\r\n\r\n    // Check for special value of position (0, 0, 0) which is used by the Renderer when graphics\r\n    // are removed before the VBO is recompacted. If this is the case, then we just project outside\r\n    // of clip space.\r\n    if (dot($position, $position) \x3e 0.0) {\r\n      // Render single point to center of the pixel to avoid subpixel filtering to affect\r\n      // the marker color\r\n      ProjectHUDAux projectAux;\r\n      vec4 posProj \x3d projectPositionHUD(projectAux);\r\n\r\n      posProjCenter \x3d alignToPixelCenter(posProj, viewport.zw);\r\n    }\r\n    else {\r\n      // Project out of clip space\r\n      posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n    }\r\n\r\n    gl_Position \x3d posProjCenter;\r\n    gl_PointSize \x3d 1.0;\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("require exports ../../../../core/tsSupport/extendsHelper dojo/text!./HUDMaterial.xml ../../../../geometry/support/aaBoundingRect ../lib/ComponentUtils ../lib/gl-matrix ../lib/GLMaterialTexture ../lib/Material ../lib/RenderPass ../lib/RenderSlot ../lib/screenSizePerspectiveUtils ../lib/ShaderVariations ../lib/Util ./internal/MaterialUtil ../../../webgl/Util".split(" "),function(P,ja,F,aa,ba,ca,G,H,da,Q,I,L,M,n,h,x){function N(h,f){void 0===f&&(f=R);if(h.textureIsSignedDistanceField){var a=
h.anchorPos;h=h.distanceFieldBoundingBox;var b=f;b[0]=a[0]*(h[2]-h[0])+h[0];b[1]=a[1]*(h[3]-h[1])+h[1]}else S.set(h.anchorPos,f);return f}var S=G.vec2d,r=G.vec3d,T=G.mat3d,z=G.mat4d,U={"bottom-left":[0,0],bottom:[.5,0],"bottom-right":[1,0],left:[0,.5],center:[.5,.5],right:[1,.5],"top-left":[0,1],top:[.5,1],"top-right":[1,1]},t=[{name:"position",count:3,type:5126,offset:0,stride:76,normalized:!1},{name:"normal",count:3,type:5126,offset:12,stride:76,normalized:!1},{name:"uv0",count:2,type:5126,offset:24,
stride:76,normalized:!1},{name:"color",count:4,type:5121,offset:32,stride:76,normalized:!1},{name:"size",count:2,type:5126,offset:36,stride:76,normalized:!1},{name:"auxpos1",count:4,type:5126,offset:44,stride:76,normalized:!1},{name:"auxpos2",count:4,type:5126,offset:60,stride:76,normalized:!1}],ea={texCoordScale:[1,1],occlusionTest:!0,binaryHighlightOcclusion:!0,drawInSecondSlot:!1,color:[1,1,1,1],outlineColor:[1,1,1,1],outlineSize:0,textureIsSignedDistanceField:!1,distanceFieldBoundingBox:null,
vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],screenOffset:[0,0],verticalOffset:null,screenSizePerspective:null,screenSizePerspectiveAlignment:null,anchorPos:U.center,shaderPolygonOffset:1E-5,polygonOffset:!1,textureId:null,centerOffsetUnits:"world",debugDrawBorder:!1};P=function(y){function f(a,b){b=y.call(this,
b)||this;b._textureDirty=!1;b.params=h.copyParameters(a,ea);"string"===typeof b.params.anchorPos&&(b.params.anchorPos=U[b.params.anchorPos]);return b}F(f,y);f.prototype.dispose=function(){};f.prototype.getParameterValues=function(){var a=this.params;return{color:a.color,texCoordScale:a.texCoordScale,polygonOffset:a.polygonOffset,anchorPos:a.anchorPos,screenOffset:a.screenOffset,verticalOffset:a.verticalOffset,screenSizePerspective:a.screenSizePerspective,screenSizePerspectiveAlignment:a.screenSizePerspectiveAlignment,
shaderPolygonOffset:a.shaderPolygonOffset,textureIsSignedDistanceField:a.textureIsSignedDistanceField,outlineColor:a.outlineColor,outlineSize:a.outlineSize,distanceFieldBoundingBox:a.distanceFieldBoundingBox,vvSizeEnabled:a.vvSizeEnabled,vvSizeMinSize:a.vvSizeMinSize,vvSizeMaxSize:a.vvSizeMaxSize,vvSizeOffset:a.vvSizeOffset,vvSizeFactor:a.vvSizeFactor,vvColorEnabled:a.vvColorEnabled,vvColorValues:a.vvColorValues,vvColorColors:a.vvColorColors,textureId:a.textureId,occlusionTest:a.occlusionTest,binaryHighlightOcclusion:a.binaryHighlightOcclusion,
centerOffsetUnits:a.centerOffsetUnits,debugDrawBorder:a.debugDrawBorder,drawInSecondSlot:a.drawInSecondSlot}};f.prototype.setParameterValues=function(a){for(var b in a)"textureId"===b&&n.assert(!!this.params.textureId,"Can only change texture of material that already has a texture"),this.params[b]=a[b];this.notifyDirty("matChanged")};f.prototype.getParams=function(){return this.params};f.prototype.getOutputAmount=function(a){return 114*a};f.prototype.getInstanceBufferLayout=function(){};f.prototype.getVertexBufferLayout=
function(){return t};f.prototype.fillInterleaved=function(a,b,c,e,d,f){var m=4*f,g=a.indices[n.VertexAttrConstants.POSITION],q=a.vertexAttr[n.VertexAttrConstants.POSITION].data,k=f+x.findAttribute(t,n.VertexAttrConstants.POSITION).offset/4;for(e=0;e<g.length;++e){var l=3*g[e];h.fill(q,l,d,k,b,3);k+=19;h.fill(q,l,d,k,b,3);k+=19;h.fill(q,l,d,k,b,3);k+=19;h.fill(q,l,d,k,b,3);k+=19;h.fill(q,l,d,k,b,3);k+=19;h.fill(q,l,d,k,b,3);k+=19}b=a.indices[n.VertexAttrConstants.NORMAL];q=a.vertexAttr[n.VertexAttrConstants.NORMAL].data;
k=f+x.findAttribute(t,n.VertexAttrConstants.NORMAL).offset/4;for(e=0;e<b.length;++e)l=3*b[e],h.fill(q,l,d,k,c,3),k+=19,h.fill(q,l,d,k,c,3),k+=19,h.fill(q,l,d,k,c,3),k+=19,h.fill(q,l,d,k,c,3),k+=19,h.fill(q,l,d,k,c,3),k+=19,h.fill(q,l,d,k,c,3),k+=19;e=a.vertexAttr[n.VertexAttrConstants.UV0].data;null==e||3>=e.length?(c=l=0,b=this.params.texCoordScale[0],q=this.params.texCoordScale[1]):(l=a.vertexAttr[n.VertexAttrConstants.UV0].data[0],c=a.vertexAttr[n.VertexAttrConstants.UV0].data[1],b=a.vertexAttr[n.VertexAttrConstants.UV0].data[2],
q=a.vertexAttr[n.VertexAttrConstants.UV0].data[3]);b=Math.min(1.99999,b+1);q=Math.min(1.99999,q+1);k=f+x.findAttribute(t,n.VertexAttrConstants.UV0).offset/4;for(e=0;e<g.length;++e)d[k]=l,d[k+1]=c,k+=19,d[k]=b,d[k+1]=c,k+=19,d[k]=b,d[k+1]=q,k+=19,d[k]=b,d[k+1]=q,k+=19,d[k]=l,d[k+1]=q,k+=19,d[k]=l,d[k+1]=c,k+=19;g=a.indices[n.VertexAttrConstants.COLOR];c=a.vertexAttr[n.VertexAttrConstants.COLOR].data;m+=x.findAttribute(t,n.VertexAttrConstants.COLOR).offset;b=new Uint8Array(d.buffer);for(e=0;e<g.length;++e)l=
4*g[e],h.fillColor(c,l,b,m,4),m+=76,h.fillColor(c,l,b,m,4),m+=76,h.fillColor(c,l,b,m,4),m+=76,h.fillColor(c,l,b,m,4),m+=76,h.fillColor(c,l,b,m,4),m+=76,h.fillColor(c,l,b,m,4),m+=76;l=a.indices[n.VertexAttrConstants.SIZE];m=a.vertexAttr[n.VertexAttrConstants.SIZE].data;g=f+x.findAttribute(t,n.VertexAttrConstants.SIZE).offset/4;for(e=0;e<l.length;++e)c=m[2*l[e]],b=m[2*l[e]+1],d[g]=c,d[g+1]=b,g+=19,d[g]=c,d[g+1]=b,g+=19,d[g]=c,d[g+1]=b,g+=19,d[g]=c,d[g+1]=b,g+=19,d[g]=c,d[g+1]=b,g+=19,d[g]=c,d[g+1]=
b,g+=19;if(null!=a.indices[n.VertexAttrConstants.AUXPOS1]&&null!=a.vertexAttr[n.VertexAttrConstants.AUXPOS1])for(m=a.indices[n.VertexAttrConstants.AUXPOS1],g=a.vertexAttr[n.VertexAttrConstants.AUXPOS1].data,c=f+x.findAttribute(t,"auxpos1").offset/4,e=0;e<m.length;++e)l=4*m[e],h.fill(g,l,d,c,null,4),c+=19,h.fill(g,l,d,c,null,4),c+=19,h.fill(g,l,d,c,null,4),c+=19,h.fill(g,l,d,c,null,4),c+=19,h.fill(g,l,d,c,null,4),c+=19,h.fill(g,l,d,c,null,4),c+=19;if(null!=a.indices[n.VertexAttrConstants.AUXPOS2]&&
null!=a.vertexAttr[n.VertexAttrConstants.AUXPOS2])for(m=a.indices[n.VertexAttrConstants.AUXPOS2],a=a.vertexAttr[n.VertexAttrConstants.AUXPOS2].data,f+=x.findAttribute(t,"auxpos2").offset/4,e=0;e<m.length;++e)l=4*m[e],h.fill(a,l,d,f,null,4),f+=19,h.fill(a,l,d,f,null,4),f+=19,h.fill(a,l,d,f,null,4),f+=19,h.fill(a,l,d,f,null,4),f+=19,h.fill(a,l,d,f,null,4),f+=19,h.fill(a,l,d,f,null,4),f+=19};f.prototype.intersect=function(a,b,c,e,d,f,h,g){if(e.isSelection&&e.enableHUDSelection&&!ca.isAllHidden(b.componentVisibilities,
a.data.componentOffsets)){var m=a.getData();a=this.params;d=b=1;z.toMat3(c,J);if(g){d=g(V);b=d[0];d=d[5];g=J;f=g[0];var k=g[1],l=g[2],y=g[3],A=g[4],p=g[5],u=g[6],v=g[7],t=g[8],C=1/Math.sqrt(f*f+k*k+l*l),D=1/Math.sqrt(y*y+A*A+p*p),x=1/Math.sqrt(u*u+v*v+t*t);g[0]=f*C;g[1]=k*C;g[2]=l*C;g[3]=y*D;g[4]=A*D;g[5]=p*D;g[6]=u*x;g[7]=v*x;g[8]=t*x}g=m.getVertexAttr()[n.VertexAttrConstants.POSITION];f=m.getVertexAttr()[n.VertexAttrConstants.SIZE];m=m.getVertexAttr()[n.VertexAttrConstants.NORMAL];n.assert(3<=g.size);
k=e.point;l=e.camera;y=N(a);for(A=0;A<g.data.length/g.size;A++)p=A*g.size,r.set3(g.data[p],g.data[p+1],g.data[p+2],B),z.multiplyVec3(c,B,B),p=A*f.size,w[0]=f.data[p]*b,w[1]=f.data[p+1]*d,z.multiplyVec3(l.viewMatrix,B),p=A*m.size,r.set3(m.data[p],m.data[p+1],m.data[p+2],W),this.applyVerticalOffsetTransformation(B,W,J,l,X),l.applyProjection(B,E),-1<E[0]&&(p=Math.floor(E[0]),v=Math.floor(E[1]),L.applyPrecomputedScaleFactorVec2(w,X.factor,w),p=p-K-(0<y[0]?w[0]*y[0]:0),u=p+w[0]+2*K,v=v-K-(0<y[1]?w[1]*
y[1]:0),t=v+w[1]+2*K,a.textureIsSignedDistanceField&&(C=a.outlineSize/2,D=a.distanceFieldBoundingBox,p+=w[0]*D[0],v+=w[1]*D[1],u-=w[0]*(1-D[2]),t-=w[1]*(1-D[3]),p-=C,u+=C,v-=C,t+=C),k[0]>p&&k[0]<u&&k[1]>v&&k[1]<t&&(u=e.p0,v=e.p1,z.multiplyVec3(z.inverse(l.viewMatrix,fa),B,Y),E[0]=k[0],E[1]=k[1],l.unprojectPoint(E,B),p=r.negate(e.getDirection(),r.create()),u=r.dist(u,B)/r.dist(u,v),h(u,p,-1,1,!0,Y)))}};f.prototype.normalAndViewAngle=function(a,b,c,e){void 0===e&&(e=O);T.multiplyVec3(b,a,e.normal);
z.multiplyVec3(c.viewInverseTransposeMatrix,e.normal);e.cosAngle=r.dot(Z,ga);return e};f.prototype.updateScaleInfo=function(a,b,c){b=this.params;b.screenSizePerspective?a.factor=L.precomputeScaleFactor(O.cosAngle,c,b.screenSizePerspective,a.factor):(a.factor.scale=1,a.factor.factor=0,a.factor.minPixelSize=0,a.factor.paddingPixels=0);b.screenSizePerspectiveAlignment?(a.scaleAlignment=L.precomputeScale(O.cosAngle,c,b.screenSizePerspectiveAlignment),a.minPixelSizeAlignment=b.screenSizePerspectiveAlignment.parameters.minPixelSize):
(a.scaleAlignment=a.factor.scale,a.minPixelSizeAlignment=a.factor.minPixelSize)};f.prototype.applyVerticalOffsetTransformation=function(a,b,c,e,d,f){var m=this.params;16===c.length&&(c=z.toMat3(c,J));if(!m.verticalOffset||!m.verticalOffset.screenLength)return d&&(m.screenSizePerspective||m.screenSizePerspectiveAlignment)?(e=this.normalAndViewAngle(b,c,e),m=r.length(a),this.updateScaleInfo(d,e.cosAngle,m)):d&&(d.factor.scale=1,d.scaleAlignment=1),f?r.set(a,f):a;b=this.normalAndViewAngle(b,c,e);c=r.length(a);
e=h.verticalOffsetAtDistance(e,c,m.verticalOffset,b.cosAngle,m.screenSizePerspectiveAlignment||m.screenSizePerspective);d&&this.updateScaleInfo(d,b.cosAngle,c);return r.add(a,r.scale(b.normal,e),f)};f.prototype.getGLMaterials=function(){return{color:ha,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:ia}};f.prototype.getAllTextureIds=function(){return[this.params.textureId]};f.prototype.setTextureDirty=function(){this._textureDirty=!0};f.prototype.calculateRelativeScreenBounds=function(a,
b,c){void 0===c&&(c=ba.create());var e=this.params,d=c;void 0===d&&(d=R);S.set(e.anchorPos,d);d[0]*=-a[0];d[1]*=-a[1];d[0]+=e.screenOffset[0]*b;d[1]+=e.screenOffset[1]*b;c[2]=c[0]+a[0];c[3]=c[1]+a[1];return c};f.prototype.calculateAnchorPosForRendering=function(a){return N(this.params,a)};f.loadShaders=function(a,b,c){a._parse(aa);var e=function(a){a.addDefine("OcclTest","OCCL_TEST");a.addDefine("SDF","SIGNED_DISTANCE_FIELD");a.addDefine("vvSize","VV_SIZE");a.addDefine("vvColor","VV_COLOR");a.addDefine("verticalOffset",
"VERTICAL_OFFSET");a.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");a.addDefine("centerOffsetUnitsScreen","CENTER_OFFSET_UNITS_SCREEN")},d=new M("hud",["vertexShaderHUD","fragmentShaderHUD"],null,b,a,c);e(d);d.addDefine("debugDrawBorder","DEBUG_DRAW_BORDER");b.addShaderVariations("hud-material-shader-variations",d);d=new M("hudHighlight",["vertexShaderHUD","fragmentShaderHUDHighlight"],null,b,a,c);e(d);d.addDefine("binaryHighlightOcclusion","BINARY_HIGHLIGHT_OCCLUSION");b.addShaderVariations("hud-material-highlight-shader-variations",
d);a=new M("hudOcclusionTestPixel",["vertexShaderOcclusionTestPixel","fragmentShaderSimple"],null,b,a,c);a.addDefine("verticalOffset","VERTICAL_OFFSET");a.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");a.addDefine("centerOffsetUnitsScreen","CENTER_OFFSET_UNITS_SCREEN");b.addShaderVariations("hud-material-occlusion-test-pixel-shader-variations",a)};f.shouldRenderVisibilityDuringRenderPass=function(a){return a===Q.MATERIAL||Q.MATERIAL_HIGHLIGHT};return f}(da);H=function(n){function f(a,
b,c){b=n.call(this,a,b,c,a.getParams().textureId)||this;b.params=h.copyParameters(a.getParams());b.selectProgram();b.selectSlot();return b}F(f,n);f.prototype.selectSlot=function(){this.mainSlot=this.params.drawInSecondSlot?I.HUDMATERIAL2:I.HUDMATERIAL1};f.prototype.beginSlot=function(a){return a===this.mainSlot};f.prototype.getProgram=function(){return this.program};f.prototype.updateParameters=function(){var a=this.material.getParams(),b=this.params;b.color=a.color;b.texCoordScale=a.texCoordScale;
b.polygonOffset=a.polygonOffset;b.anchorPos=a.anchorPos;b.screenOffset=a.screenOffset;b.verticalOffset=a.verticalOffset;b.screenSizePerspective=a.screenSizePerspective;b.screenSizePerspectiveAlignment=a.screenSizePerspectiveAlignment;b.shaderPolygonOffset=a.shaderPolygonOffset;b.textureIsSignedDistanceField=a.textureIsSignedDistanceField;b.outlineColor=a.outlineColor;b.outlineSize=a.outlineSize;b.vvSizeEnabled=a.vvSizeEnabled;b.vvSizeMinSize=a.vvSizeMinSize;b.vvSizeMaxSize=a.vvSizeMaxSize;b.vvSizeOffset=
a.vvSizeOffset;b.vvSizeFactor=a.vvSizeFactor;b.vvColorEnabled=a.vvColorEnabled;b.vvColorValues=a.vvColorValues;b.vvColorColors=a.vvColorColors;this.updateTexture(a.textureId);this.selectProgram();this.selectSlot()};f.prototype.bindRender=function(a,b){var c=this.params,e=this.getProgram();this.bindTexture(a,e);e.setUniform1i("hudVisibilityTexture",1);a.bindTexture(b.hudVisibilityTexture,1);a.setActiveTexture(0);e.setUniform1f("uRenderTransparentlyOccludedHUD","occluded"===b.renderTransparentlyOccludedHUD?
1:"notOccluded"===b.renderTransparentlyOccludedHUD?0:.75);e.setUniform4fv("overrideColor",c.color);e.setUniform1f("pixelRatio",b.pixelRatio);c.textureIsSignedDistanceField&&(e.setUniform4fv("outlineColor",c.outlineColor),e.setUniform1f("outlineSize",c.outlineSize));c.vvSizeEnabled&&(e.setUniform3fv("vvSizeMinSize",c.vvSizeMinSize),e.setUniform3fv("vvSizeMaxSize",c.vvSizeMaxSize),e.setUniform3fv("vvSizeOffset",c.vvSizeOffset),e.setUniform3fv("vvSizeFactor",c.vvSizeFactor));c.vvColorEnabled&&(e.setUniform1fv("vvColorValues",
c.vvColorValues),e.setUniform4fv("vvColorColors",c.vvColorColors));e.setUniform2fv("texScale",c.texCoordScale);e.setUniform2f("screenOffset",2*c.screenOffset[0],2*c.screenOffset[1]);e.setUniform2fv("anchorPos",N(c));c.polygonOffset&&(a.setPolygonOffsetFillEnabled(!0),a.setPolygonOffset(0,-4));a.setBlendingEnabled(!0);a.setBlendFunction(1,771)};f.prototype.bindProjection=function(a,b){this.material._textureDirty&&(this.renderTexture(a),this.material._textureDirty=!1);var c=b.cameraAboveGround?1:-1,
e=this.getProgram(),d=this.params;a.bindProgram(e);e.setUniform1f("cameraGroundRelative",c);e.setUniform1f("polygonOffset",d.shaderPolygonOffset);e.setUniform4fv("viewport",b.viewport);h.bindVerticalOffset(d.verticalOffset,b,e);e.setUniformMatrix4fv("viewNormal",b.viewInvTransp);d.screenSizePerspective&&(h.bindScreenSizePerspective(d.screenSizePerspective,e,"screenSizePerspective"),h.bindScreenSizePerspective(d.screenSizePerspectiveAlignment||d.screenSizePerspective,e,"screenSizePerspectiveAlignment"))};
f.prototype.releaseRender=function(a){a.setPolygonOffsetFillEnabled(!1);a.setBlendFunction(770,771);a.setBlendingEnabled(!1)};f.prototype.bindView=function(a,b){a=b.origin;var c=this.getProgram();h.bindView(a,b.view,c);h.bindCamPos(a,b.viewInvTransp,c)};f.prototype.bindInstance=function(a,b){a=this.getProgram();a.setUniformMatrix4fv("model",b.transformation);a.setUniformMatrix4fv("modelNormal",b.transformationNormal)};f.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return f}(H);var ha=
function(h){function f(a,b,c){a=h.call(this,a,b,c)||this;a.isOcclusionSlot=!1;return a}F(f,h);f.prototype.selectProgram=function(){var a=this.params;this.programOcclusionTestPixel=this.programRep.getShaderVariationsProgram("hud-material-occlusion-test-pixel-shader-variations",[!!a.verticalOffset,!!a.screenSizePerspective,"screen"===a.centerOffsetUnits]);this.program=this.programRep.getShaderVariationsProgram("hud-material-shader-variations",[a.occlusionTest,a.textureIsSignedDistanceField,!!a.vvSizeEnabled,
!!a.vvColorEnabled,!!a.verticalOffset,!!a.screenSizePerspective,"screen"===a.centerOffsetUnits,!!a.debugDrawBorder])};f.prototype.getDrawMode=function(a){a=a.gl;return this.isOcclusionSlot?a.POINTS:a.TRIANGLES};f.prototype.release=function(a){a.setDepthFunction(a.gl.LESS);this.isOcclusionSlot||this.releaseRender(a)};f.prototype.bind=function(a,b){var c=a.gl;this.bindProjection(a,b);var e=this.getProgram();a.setDepthTestEnabled(!0);a.setDepthFunction(c.LEQUAL);this.isOcclusionSlot?e.setUniform4f("color",
1,1,1,1):(this.bindRender(a,b),this.bindTexture(a,e))};f.prototype.getProgram=function(){return this.isOcclusionSlot?this.programOcclusionTestPixel:this.program};f.prototype.getPrograms=function(){return[this.programOcclusionTestPixel,this.program]};f.prototype.beginSlot=function(a){if(this.params.occlusionTest)return this.isOcclusionSlot=a===I.OCCLUSION_PIXELS,a===I.OCCLUSION_PIXELS||a===this.mainSlot;this.isOcclusionSlot=!1;return a===this.mainSlot};return f}(H),ia=function(h){function f(){return null!==
h&&h.apply(this,arguments)||this}F(f,h);f.prototype.selectProgram=function(){var a=this.params;this.program=this.programRep.getShaderVariationsProgram("hud-material-highlight-shader-variations",[a.occlusionTest,a.textureIsSignedDistanceField,!!a.vvSizeEnabled,!!a.vvColorEnabled,!!a.verticalOffset,!!a.screenSizePerspective,"screen"===a.centerOffsetUnits,a.binaryHighlightOcclusion])};f.prototype.bind=function(a,b){this.bindProjection(a,b);this.bindRender(a,b)};f.prototype.release=function(a){this.releaseRender(a)};
return f}(H),X={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},scaleAlignment:0,minPixelSizeAlignment:0},R=[0,0],B=r.create(),W=r.create(),E=r.create(),Z=r.create(),Y=r.create(),J=T.create(),fa=z.create(),O={normal:Z,cosAngle:0},V=z.create();z.identity(V);var K=1,w=[0,0],ga=[0,0,1];return P});